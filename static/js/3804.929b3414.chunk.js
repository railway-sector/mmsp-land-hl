"use strict";(self.webpackChunkmmsp_land_hl=self.webpackChunkmmsp_land_hl||[]).push([[3804],{19061:(e,t,n)=>{n.d(t,{H:()=>me,b:()=>fe,c:()=>pe,f:()=>ve});var o,i,r,a,s,l,c,u,f,d,p,h,v,g,m,x,w,b,A,y,C,P,S,z,O,M,D,V,H,F,T,j,R,_,E,I=n(57528),U=n(19555),B=n(72745),W=n(55855),G=n(14556),N=n(26917),q=n(90080),L=n(98720),Y=n(40318),Q=n(38280),k=n(62374),Z=n(87236),X=n(66763),$=n(80883),J=n(69817),K=n(3799),ee=n(95756),te=n(51596),ne=n(20123),oe=n(58350),ie=n(23148),re=n(21390),ae=n(86955),se=n(4653),le=n(70367),ce=n(2687),ue=n(75569);function fe(e){const t=new ce.N5,{signedDistanceFieldEnabled:n,occlusionTestEnabled:B,horizonCullingEnabled:fe,pixelSnappingEnabled:ve,hasScreenSizePerspective:me,debugDrawLabelBorder:xe,hasVVSize:we,hasVVColor:be,hasRotation:Ae,occludedFragmentFade:ye,sampleSignedDistanceFieldTexelCenter:Ce}=e;t.include(Y.Q,e),t.vertex.include(N.rA,e);const{occlusionPass:Pe,output:Se,oitPass:ze}=e;if(Pe)return t.include(Q.I,e),t;const{vertex:Oe,fragment:Me}=t;t.include(J.Y6),t.include(X.A,e),t.include(q.g,e),B&&t.include(k.y),Me.include($.a),t.varyings.add("vcolor","vec4"),t.varyings.add("vtc","vec2"),t.varyings.add("vsize","vec2");const De=9===Se,Ve=De&&B;Ve&&t.varyings.add("voccluded","float"),Oe.uniforms.add(new te.I("viewport",e=>e.camera.fullViewport),new ee.G("screenOffset",(e,t)=>(0,U.hZ)(he,2*e.screenOffset[0]*t.camera.pixelRatio,2*e.screenOffset[1]*t.camera.pixelRatio)),new ee.G("anchorPosition",e=>pe(e)),new oe.E("materialColor",e=>e.color),new re.m("materialRotation",e=>e.rotation),new le.N("tex",e=>e.texture)),(0,K.Nz)(Oe),n&&(Oe.uniforms.add(new oe.E("outlineColor",e=>e.outlineColor)),Me.uniforms.add(new oe.E("outlineColor",e=>de(e)?e.outlineColor:W.uY),new re.m("outlineSize",e=>de(e)?e.outlineSize:0))),fe&&Oe.uniforms.add(new ne.V("pointDistanceSphere",(e,t)=>{const n=t.camera.eye,o=e.origin;return(0,W.fA)(o[0]-n[0],o[1]-n[1],o[2]-n[2],G.$O.radius)})),ve&&Oe.include(L.K),me&&((0,J.pM)(Oe),(0,J.OH)(Oe)),xe&&t.varyings.add("debugBorderCoords","vec4"),t.attributes.add("uv0","vec2"),t.attributes.add("uvi","vec4"),t.attributes.add("color","vec4"),t.attributes.add("size","vec2"),t.attributes.add("rotation","float"),(we||be)&&t.attributes.add("featureAttribute","vec4"),Oe.code.add(fe?(0,ae.H)(o||(o=(0,I.A)(["bool behindHorizon(vec3 posModel) {\nvec3 camToEarthCenter = pointDistanceSphere.xyz - localOrigin;\nvec3 camToPos = pointDistanceSphere.xyz + posModel;\nfloat earthRadius = pointDistanceSphere.w;\nfloat a = dot(camToPos, camToPos);\nfloat b = dot(camToPos, camToEarthCenter);\nfloat c = dot(camToEarthCenter, camToEarthCenter) - earthRadius * earthRadius;\nreturn b > 0.0 && b < a && b * b  > a * c;\n}"]))):(0,ae.H)(i||(i=(0,I.A)(["bool behindHorizon(vec3 posModel) { return false; }"])))),Oe.main.add((0,ae.H)(r||(r=(0,I.A)(["\n    ProjectHUDAux projectAux;\n    vec4 posProj = projectPositionHUD(projectAux);\n    forwardObjectAndLayerIdColor();\n\n    if (rejectBySlice(projectAux.posModel)) {\n      // Project outside of clip plane\n      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n      return;\n    }\n\n    if (behindHorizon(projectAux.posModel)) {\n      // Project outside of clip plane\n      gl_Position = vec4(1e038, 1e038, 1e038, 1.0);\n      return;\n    }\n\n    vec2 inputSize;\n    ","\n    ","\n\n    vec2 combinedSize = inputSize * pixelRatio;\n    vec4 quadOffset = vec4(0.0);\n\n    ","\n    ","\n  "])),(0,ae.If)(me,(0,ae.H)(a||(a=(0,I.A)(["\n        inputSize = screenSizePerspectiveScaleVec2(size, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspective);\n        vec2 screenOffsetScaled = screenSizePerspectiveScaleVec2(screenOffset, projectAux.absCosAngle, projectAux.distanceToCamera, screenSizePerspectiveAlignment);"]))),(0,ae.H)(s||(s=(0,I.A)(["\n        inputSize = size;\n        vec2 screenOffsetScaled = screenOffset;"])))),(0,ae.If)(we,(0,ae.H)(l||(l=(0,I.A)(["inputSize *= vvScale(featureAttribute).xx;"])))),(0,ae.If)(B,(0,ae.H)(c||(c=(0,I.A)(["\n    bool visible = testHUDVisibility(posProj);\n    if (!visible) {\n      vtc = vec2(0.0);\n      ","\n      return;\n    }"])),(0,ae.If)(xe,"debugBorderCoords = vec4(0.5, 0.5, 1.5 / combinedSize);"))),(0,ae.If)(Ve,(0,ae.H)(u||(u=(0,I.A)(["voccluded = visible ? 0.0 : 1.0;"]))))));const He=(0,ae.H)(f||(f=(0,I.A)(["\n      vec2 uv = mix(uvi.xy, uvi.zw, bvec2(uv0));\n      vec2 texSize = vec2(textureSize(tex, 0));\n      uv = mix(vec2(1.0), uv / texSize, lessThan(uv, vec2(",")));\n      quadOffset.xy = (uv0 - anchorPosition) * 2.0 * combinedSize;\n\n      ","\n\n      quadOffset.xy = (quadOffset.xy + screenOffsetScaled) / viewport.zw * posProj.w;\n  "])),ge,(0,ae.If)(Ae,(0,ae.H)(d||(d=(0,I.A)(["\n          float angle = radians(materialRotation + rotation);\n          float cosAngle = cos(angle);\n          float sinAngle = sin(angle);\n          mat2 rotate = mat2(cosAngle, -sinAngle, sinAngle,  cosAngle);\n\n          quadOffset.xy = rotate * quadOffset.xy;\n        "]))))),Fe=ve?n?(0,ae.H)(p||(p=(0,I.A)(["posProj = alignToPixelOrigin(posProj, viewport.zw) + quadOffset;"]))):(0,ae.H)(h||(h=(0,I.A)(["posProj += quadOffset;\nif (inputSize.x == size.x) {\nposProj = alignToPixelOrigin(posProj, viewport.zw);\n}"]))):(0,ae.H)(v||(v=(0,I.A)(["posProj += quadOffset;"])));Oe.main.add((0,ae.H)(g||(g=(0,I.A)(["\n    ","\n    ","\n\n    ","\n\n    bool alphaDiscard = vcolor.a < ",";\n    ",'\n    if (alphaDiscard) {\n      // "early discard" if both symbol color (= fill) and outline color (if applicable) are transparent\n      gl_Position = vec4(1e38, 1e38, 1e38, 1.0);\n      return;\n    } else {\n      ',"\n      gl_Position = posProj;\n    }\n\n    vtc = uv;\n\n    ","\n    vsize = inputSize;\n  "])),He,be?"vcolor = interpolateVVColor(featureAttribute.y) * materialColor;":"vcolor = color / 255.0 * materialColor;",(0,ae.If)(10===Se,(0,ae.H)(m||(m=(0,I.A)(["vcolor.a = 1.0;"])))),ae.H.float(ue.Q),(0,ae.If)(n,"alphaDiscard = alphaDiscard && outlineColor.a < ".concat(ae.H.float(ue.Q),";")),Fe,(0,ae.If)(xe,(0,ae.H)(x||(x=(0,I.A)(["debugBorderCoords = vec4(uv01, 1.5 / combinedSize);"])))))),Me.uniforms.add(new le.N("tex",e=>e.texture)),ye&&!De&&Me.uniforms.add(new se.x("depthMap",e=>e.mainDepth),new ie.U("occludedOpacity",e=>e.hudOccludedFragmentOpacity));const Te=xe?(0,ae.H)(w||(w=(0,I.A)(["(isBorder > 0.0 ? 0.0 : ",")"])),ae.H.float(ue.Q)):ae.H.float(ue.Q),je=(0,ae.H)(b||(b=(0,I.A)(["\n    ","\n\n    vec2 samplePos = vtc;\n\n    ","\n\n    ","\n\n    ","\n\n    ","\n  "])),(0,ae.If)(xe,(0,ae.H)(A||(A=(0,I.A)(["float isBorder = float(any(lessThan(debugBorderCoords.xy, debugBorderCoords.zw)) || any(greaterThan(debugBorderCoords.xy, 1.0 - debugBorderCoords.zw)));"])))),(0,ae.If)(Ce,(0,ae.H)(y||(y=(0,I.A)(["\n      float txSize = float(textureSize(tex, 0).x);\n      float texelSize = 1.0 / txSize;\n\n      // Calculate how much we have to add/subtract to/from each texel to reach the size of an onscreen pixel\n      vec2 scaleFactor = (vsize - txSize) * texelSize;\n      samplePos += (vec2(1.0, -1.0) * texelSize) * scaleFactor;"])))),n?(0,ae.H)(C||(C=(0,I.A)(["\n      vec4 fillPixelColor = vcolor;\n\n      // Get distance in output units (i.e. pixels)\n\n      float sdf = texture(tex, samplePos).r;\n      float pixelDistance = sdf * vsize.x;\n\n      // Create smooth transition from the icon into its outline\n      float fillAlphaFactor = clamp(0.5 - pixelDistance, 0.0, 1.0);\n      fillPixelColor.a *= fillAlphaFactor;\n\n      if (outlineSize > 0.25) {\n        vec4 outlinePixelColor = outlineColor;\n        float clampedOutlineSize = min(outlineSize, 0.5*vsize.x);\n\n        // Create smooth transition around outline\n        float outlineAlphaFactor = clamp(0.5 - (abs(pixelDistance) - 0.5*clampedOutlineSize), 0.0, 1.0);\n        outlinePixelColor.a *= outlineAlphaFactor;\n\n        if (\n          outlineAlphaFactor + fillAlphaFactor < "," ||\n          fillPixelColor.a + outlinePixelColor.a < ","\n        ) {\n          discard;\n        }\n\n        // perform un-premultiplied over operator (see https://en.wikipedia.org/wiki/Alpha_compositing#Description)\n        float compositeAlpha = outlinePixelColor.a + fillPixelColor.a * (1.0 - outlinePixelColor.a);\n        vec3 compositeColor = vec3(outlinePixelColor) * outlinePixelColor.a +\n          vec3(fillPixelColor) * fillPixelColor.a * (1.0 - outlinePixelColor.a);\n\n        ","\n      } else {\n        if (fillAlphaFactor < ",") {\n          discard;\n        }\n\n        ","\n      }\n\n      // visualize SDF:\n      // fragColor = vec4(clamp(-pixelDistance/vsize.x*2.0, 0.0, 1.0), clamp(pixelDistance/vsize.x*2.0, 0.0, 1.0), 0.0, 1.0);\n      "])),Te,ae.H.float(ue.Q),(0,ae.If)(!De,(0,ae.H)(P||(P=(0,I.A)(["fragColor = vec4(compositeColor, compositeAlpha);"])))),Te,(0,ae.If)(!De,(0,ae.H)(S||(S=(0,I.A)(["fragColor = premultiplyAlpha(fillPixelColor);"]))))):(0,ae.H)(z||(z=(0,I.A)(["\n          vec4 texColor = texture(tex, samplePos, -0.5);\n          if (texColor.a < ",") {\n            discard;\n          }\n          ","\n          "])),Te,(0,ae.If)(!De,(0,ae.H)(O||(O=(0,I.A)(["fragColor = texColor * premultiplyAlpha(vcolor);"]))))),(0,ae.If)(ye&&!De,(0,ae.H)(M||(M=(0,I.A)(["\n        float zSample = texelFetch(depthMap, ivec2(gl_FragCoord.xy), 0).x;\n        if (zSample < gl_FragCoord.z) {\n          fragColor *= occludedOpacity;\n        }\n        "])))),(0,ae.If)(!De&&xe,(0,ae.H)(D||(D=(0,I.A)(["fragColor = mix(fragColor, vec4(1.0, 0.0, 1.0, 1.0), isBorder * 0.5);"])))));switch(Se){case 0:case 1:t.outputs.add("fragColor","vec4",0),1===Se&&t.outputs.add("fragEmission","vec4",1),1===ze&&t.outputs.add("fragAlpha","float",1===Se?2:1),Me.main.add((0,ae.H)(V||(V=(0,I.A)(["\n        ","\n        ","\n        ","\n        ",""])),je,(0,ae.If)(2===ze,(0,ae.H)(H||(H=(0,I.A)(["fragColor.rgb /= fragColor.a;"])))),(0,ae.If)(1===Se,(0,ae.H)(F||(F=(0,I.A)(["fragEmission = vec4(0.0);"])))),(0,ae.If)(1===ze,(0,ae.H)(T||(T=(0,I.A)(["fragAlpha = fragColor.a;"]))))));break;case 10:Me.main.add((0,ae.H)(j||(j=(0,I.A)(["\n        ","\n        outputObjectAndLayerIdColor();"])),je));break;case 9:t.include(Z.Q,e),Me.main.add((0,ae.H)(R||(R=(0,I.A)(["\n        ","\n        outputHighlight(",");"])),je,(0,ae.If)(Ve,(0,ae.H)(_||(_=(0,I.A)(["voccluded == 1.0"]))),(0,ae.H)(E||(E=(0,I.A)(["false"]))))))}return t}function de(e){return e.outlineColor[3]>0&&e.outlineSize>0}function pe(e){return e.textureIsSignedDistanceField?function(e,t,n){(0,U.hZ)(n,e[0]*(t[2]-t[0])+t[0],e[1]*(t[3]-t[1])+t[1])}(e.anchorPosition,e.distanceFieldBoundingBox,he):(0,U.C)(he,e.anchorPosition),he}const he=(0,B.vt)(),ve=32e3,ge=ae.H.float(ve),me=Object.freeze(Object.defineProperty({__proto__:null,build:fe,calculateAnchorPosition:pe,fullUV:ve},Symbol.toStringTag,{value:"Module"}))},20123:(e,t,n)=>{n.d(t,{V:()=>i});var o=n(87003);class i extends o.n{constructor(e,t,n){super(e,"vec4",2,(o,i,r)=>o.setUniform4fv(e,t(i,r),n))}}},36423:(e,t,n)=>{n.d(t,{$2:()=>z,$C:()=>y,Hj:()=>P,Mh:()=>S,W$:()=>m,pW:()=>C,t8:()=>A,vY:()=>O});var o=n(31633),i=n(34761),r=n(13191),a=n(9392),s=n(43047),l=n(55855),c=n(56611),u=n(42294),f=n(2413),d=n(205),p=n(5262),h=n(99773),v=n(18117),g=n(32535);function m(e,t){var n;if("point"===e.type)return b(e,t,!1);if((0,g.gr)(e))switch(e.type){case"extent":return b(e.center,t,!1);case"polygon":return b(w(e),t,!1);case"polyline":return b(x(e),t,!0);case"mesh":return b(null!==(n=(0,h.MW)(e.vertexSpace,e.spatialReference))&&void 0!==n?n:e.extent.center,t,!1);case"multipoint":return}else switch(e.type){case"extent":return b(function(e){return(0,v.TH)(.5*(e.xmax+e.xmin),.5*(e.ymax+e.ymin),null!=e.zmin&&null!=e.zmax&&isFinite(e.zmin)&&isFinite(e.zmax)?.5*(e.zmax+e.zmin):void 0,e.spatialReference)}(e),t,!0);case"polygon":return b(w(e),t,!0);case"polyline":return b(x(e),t,!0);case"multipoint":return}}function x(e){const t=e.paths[0];if(!t||0===t.length)return null;const n=(0,p.$H)(t,(0,p.Yl)(t)/2);return(0,v.TH)(n[0],n[1],n[2],e.spatialReference)}function w(e){const t=e.rings[0];if(!t||0===t.length)return null;const n=(0,d.S8)(e.rings,!!e.hasZ);return(0,v.TH)(n[0],n[1],n[2],e.spatialReference)}function b(e,t,n){const o=n?e:(0,g.EL)(e);return t&&e?(0,c.projectPoint)(e,o,t)?o:null:o}function A(e,t,n){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;if(e){t||(t=(0,f.vt)());const i=e;let r=.5*i.width*(n-1),a=.5*i.height*(n-1);return i.width<1e-7*i.height?r+=a/20:i.height<1e-7*i.width&&(a+=r/20),(0,s.s)(t,i.xmin-r-o,i.ymin-a-o,i.xmax+r+o,i.ymax+a+o),t}return null}function y(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;const o=(0,l.o8)(l.Un);return null!=e&&(o[0]=e[0],o[1]=e[1],o[2]=e[2],e.length>3&&(o[3]=e[3])),null!=t&&(o[3]=t),n&&(0,s.c)(o,o,n),o}function C(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:a.Un,t=arguments.length>1?arguments[1]:void 0,n=arguments.length>2?arguments[2]:void 0,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;const i=new Array(3);if(null==t||null==n)i[0]=1,i[1]=1,i[2]=1;else{let o,r=0;for(let a=2;a>=0;a--){const s=e[a],l=null!=s,c=0===a&&!o&&!l,u=n[a];let f;"symbol-value"===s||c?f=0!==u?t[a]/u:1:l&&"proportional"!==s&&isFinite(s)&&(f=0!==u?s/u:1),null!=f&&(i[a]=f,o=f,r=Math.max(r,Math.abs(f)))}for(let e=2;e>=0;e--)null==i[e]?i[e]=o:0===i[e]&&(i[e]=.001*r)}for(let r=2;r>=0;r--)i[r]/=o;return(0,a.ci)(i)}function P(e){return S(function(e){return null!=e.isPrimitive}(e)?[e.width,e.depth,e.height]:e)?null:"Symbol sizes may not be negative values"}function S(e){const t=e=>null==e||e>=0;return Array.isArray(e)?e.every(t):t(e)}function z(e,t,n){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:(0,r.vt)();return e&&(0,i.Qr)(o,o,-e/180*Math.PI),t&&(0,i.eL)(o,o,t/180*Math.PI),n&&(0,i.Z8)(o,o,n/180*Math.PI),o}function O(e,t,n){if(null!=n.minDemResolution)return n.minDemResolution;const i=(0,o.GA)(t),r=(0,u.VL)(e)*i,a=(0,u.yr)(e)*i,s=(0,u.uJ)(e)*(t.isGeographic?1:i);return 0===r&&0===a&&0===s?n.minDemResolutionForPoints:.01*Math.max(r,a,s)}},38280:(e,t,n)=>{n.d(t,{I:()=>c});var o,i,r=n(57528),a=n(98720),s=n(94192),l=n(86955);function c(e,t){const{vertex:n,fragment:c}=e;e.include(s.Z,t),n.include(a.K),n.main.add((0,l.H)(o||(o=(0,r.A)(["vec4 posProjCenter;\nif (dot(position, position) > 0.0) {\nProjectHUDAux projectAux;\nvec4 posProj = projectPositionHUD(projectAux);\nposProjCenter = alignToPixelCenter(posProj, viewport.zw);\nforwardViewPosDepth(projectAux.posView);\nvec3 vpos = projectAux.posModel;\nif (rejectBySlice(vpos)) {\nposProjCenter = vec4(1e038, 1e038, 1e038, 1.0);\n}\n} else {\nposProjCenter = vec4(1e038, 1e038, 1e038, 1.0);\n}\ngl_Position = posProjCenter;\ngl_PointSize = 1.0;"])))),c.main.add((0,l.H)(i||(i=(0,r.A)(["fragColor = vec4(1);\nif(discardByTerrainDepth()) {\nfragColor.g = 0.5;\n}"]))))}},40318:(e,t,n)=>{n.d(t,{Q:()=>w,R:()=>x});var o,i,r,a,s,l,c,u=n(57528),f=n(25530),d=n(69817),p=n(3799),h=n(51596),v=n(23148),g=n(21390),m=n(86955);const x=.5;function w(e,t){e.include(d.Y6),e.attributes.add("position","vec3"),e.attributes.add("normal","vec3"),e.attributes.add("centerOffsetAndDistance","vec4");const n=e.vertex;(0,p.NB)(n,t),(0,p.yu)(n,t),n.uniforms.add(new h.I("viewport",e=>e.camera.fullViewport),new g.m("polygonOffset",e=>e.shaderPolygonOffset),new v.U("cameraGroundRelative",e=>e.camera.aboveGround?1:-1)),t.hasVerticalOffset&&(0,f.VQ)(n),n.code.add((0,m.H)(o||(o=(0,u.A)(["struct ProjectHUDAux {\nvec3 posModel;\nvec3 posView;\nvec3 vnormal;\nfloat distanceToCamera;\nfloat absCosAngle;\n};"])))),n.code.add((0,m.H)(i||(i=(0,u.A)(["\n    float applyHUDViewDependentPolygonOffset(float pointGroundDistance, float absCosAngle, inout vec3 posView) {\n      float pointGroundSign = ",";\n      if (pointGroundSign == 0.0) {\n        pointGroundSign = cameraGroundRelative;\n      }\n\n      // cameraGroundRelative is -1 if camera is below ground, 1 if above ground\n      // groundRelative is 1 if both camera and symbol are on the same side of the ground, -1 otherwise\n      float groundRelative = cameraGroundRelative * pointGroundSign;\n\n      // view angle dependent part of polygon offset emulation: we take the absolute value because the sign that is\n      // dropped is instead introduced using the ground-relative position of the symbol and the camera\n      if (polygonOffset > .0) {\n        float cosAlpha = clamp(absCosAngle, 0.01, 1.0);\n        float tanAlpha = sqrt(1.0 - cosAlpha * cosAlpha) / cosAlpha;\n        float factor = (1.0 - tanAlpha / viewport[2]);\n\n        // same side of the terrain\n        if (groundRelative > 0.0) {\n          posView *= factor;\n        }\n        // opposite sides of the terrain\n        else {\n          posView /= factor;\n        }\n      }\n\n      return groundRelative;\n    }\n  "])),t.terrainDepthTest?m.H.float(0):(0,m.H)(r||(r=(0,u.A)(["sign(pointGroundDistance)"]))))),t.draped&&!t.hasVerticalOffset||(0,p.S7)(n),t.draped||(n.uniforms.add(new v.U("perDistancePixelRatio",e=>Math.tan(e.camera.fovY/2)/(e.camera.fullViewport[2]/2))),n.code.add((0,m.H)(a||(a=(0,u.A)(["\n    void applyHUDVerticalGroundOffset(vec3 normalModel, inout vec3 posModel, inout vec3 posView) {\n      float distanceToCamera = length(posView);\n\n      // Compute offset in world units for a half pixel shift\n      float pixelOffset = distanceToCamera * perDistancePixelRatio * ",";\n\n      // Apply offset along normal in the direction away from the ground surface\n      vec3 modelOffset = normalModel * cameraGroundRelative * pixelOffset;\n\n      // Apply the same offset also on the view space position\n      vec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;\n\n      posModel += modelOffset;\n      posView += viewOffset;\n    }\n  "])),m.H.float(x)))),t.screenCenterOffsetUnitsEnabled&&(0,p.Nz)(n),t.hasScreenSizePerspective&&(0,d.OH)(n),n.code.add((0,m.H)(s||(s=(0,u.A)(["\n    vec4 projectPositionHUD(out ProjectHUDAux aux) {\n      vec3 centerOffset = centerOffsetAndDistance.xyz;\n      float pointGroundDistance = centerOffsetAndDistance.w;\n\n      aux.posModel = position;\n      aux.posView = (view * vec4(aux.posModel, 1.0)).xyz;\n      aux.vnormal = normal;\n      ","\n\n      // Screen sized offset in world space, used for example for line callouts\n      // Note: keep this implementation in sync with the CPU implementation, see\n      //   - MaterialUtil.verticalOffsetAtDistance\n      //   - HUDMaterial.applyVerticalOffsetTransformation\n\n      aux.distanceToCamera = length(aux.posView);\n\n      vec3 viewDirObjSpace = normalize(cameraPosition - aux.posModel);\n      float cosAngle = dot(aux.vnormal, viewDirObjSpace);\n\n      aux.absCosAngle = abs(cosAngle);\n\n      ","\n\n      ","\n\n      ","\n\n      float groundRelative = applyHUDViewDependentPolygonOffset(pointGroundDistance, aux.absCosAngle, aux.posView);\n\n      ","\n\n      vec4 posProj = proj * vec4(aux.posView, 1.0);\n\n      ","\n\n      ","\n\n      // constant part of polygon offset emulation\n      posProj.z -= groundRelative * polygonOffset * posProj.w;\n      return posProj;\n    }\n  "])),t.draped?"":"applyHUDVerticalGroundOffset(aux.vnormal, aux.posModel, aux.posView);",t.hasScreenSizePerspective&&(t.hasVerticalOffset||t.screenCenterOffsetUnitsEnabled)?"vec3 perspectiveFactor = screenSizePerspectiveScaleFactor(aux.absCosAngle, aux.distanceToCamera, screenSizePerspectiveAlignment);":"",t.hasVerticalOffset?t.hasScreenSizePerspective?"float verticalOffsetScreenHeight = applyScreenSizePerspectiveScaleFactorFloat(verticalOffset.x, perspectiveFactor);":"float verticalOffsetScreenHeight = verticalOffset.x;":"",t.hasVerticalOffset?(0,m.H)(l||(l=(0,u.A)(["\n            float worldOffset = clamp(verticalOffsetScreenHeight * verticalOffset.y * aux.distanceToCamera, verticalOffset.z, verticalOffset.w);\n            vec3 modelOffset = aux.vnormal * worldOffset;\n            aux.posModel += modelOffset;\n            vec3 viewOffset = (viewNormal * vec4(modelOffset, 1.0)).xyz;\n            aux.posView += viewOffset;\n            // Since we elevate the object, we need to take that into account\n            // in the distance to ground\n            pointGroundDistance += worldOffset;"]))):"",t.screenCenterOffsetUnitsEnabled?"":(0,m.H)(c||(c=(0,u.A)(["\n            // Apply x/y in view space, but z in screen space (i.e. along posView direction)\n            aux.posView += vec3(centerOffset.x, centerOffset.y, 0.0);\n\n            // Same material all have same z != 0.0 condition so should not lead to\n            // branch fragmentation and will save a normalization if it's not needed\n            if (centerOffset.z != 0.0) {\n              aux.posView -= normalize(aux.posView) * centerOffset.z;\n            }\n          "]))),t.screenCenterOffsetUnitsEnabled?t.hasScreenSizePerspective?"float centerOffsetY = applyScreenSizePerspectiveScaleFactorFloat(centerOffset.y, perspectiveFactor);":"float centerOffsetY = centerOffset.y;":"",t.screenCenterOffsetUnitsEnabled?"posProj.xy += vec2(centerOffset.x, centerOffsetY) * pixelRatio * 2.0 / viewport.zw * posProj.w;":""))}},62374:(e,t,n)=>{n.d(t,{y:()=>u});var o,i=n(57528),r=n(98720),a=n(51596),s=n(23148),l=n(86955),c=n(4653);function u(e){e.vertex.uniforms.add(new s.U("renderTransparentlyOccludedHUD",e=>0===e.hudRenderStyle?1:1===e.hudRenderStyle?0:.75),new a.I("viewport",e=>e.camera.fullViewport),new c.x("hudVisibilityTexture",e=>{var t;return null===(t=e.hudVisibility)||void 0===t?void 0:t.getTexture()})),e.vertex.include(r.K),e.vertex.code.add((0,l.H)(o||(o=(0,i.A)(["bool testHUDVisibility(vec4 posProj) {\nvec4 posProjCenter = alignToPixelCenter(posProj, viewport.zw);\nvec4 occlusionPixel = texture(hudVisibilityTexture, .5 + .5 * posProjCenter.xy / posProjCenter.w);\nif (renderTransparentlyOccludedHUD > 0.5) {\nreturn occlusionPixel.r * occlusionPixel.g > 0.0 && occlusionPixel.g * renderTransparentlyOccludedHUD < 1.0;\n}\nreturn occlusionPixel.r * occlusionPixel.g > 0.0 && occlusionPixel.g == 1.0;\n}"]))))}},70667:(e,t,n)=>{n.d(t,{Uf:()=>m,te:()=>h,xJ:()=>w,zh:()=>x});var o=n(19555),i=n(72745),r=n(55855),a=n(34111),s=n(482),l=n(44815),c=n(75002),u=n(94587),f=n(38496),d=n(50468),p=n(17345);function h(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;const i=[],u=t.mapPositions,h=function(e,t){const{attributeData:{position:n},removeDuplicateStartEnd:o}=e,i=function(e){const t=e.length;return e[0]===e[t-3]&&e[1]===e[t-2]&&e[2]===e[t-1]}(n)&&o,r=n.length/3-(i?1:0),a=new Array(2*(r-1)),s=i?n.slice(0,-3):n;let l=0;for(let u=0;u<r-1;u++)a[l++]=u,a[l++]=u+1;const c=new d.n(s,a,3,i);return t.push(["position",c]),c}(t,i),x=h.data,w=h.indices.length,b=(0,f.EH)(w);return function(e,t,n){if(null!=e.attributeData.colorFeature)return;const o=e.attributeData.color;t.push(["color",new d.n(null!==o&&void 0!==o?o:r.Un,n,4)])}(t,i,b),function(e,t,n){var o;null==e.attributeData.sizeFeature&&t.push(["size",new d.n([null!==(o=e.attributeData.size)&&void 0!==o?o:1],n,1,!0)])}(t,i,b),function(e,t,n){e.attributeData.normal&&t.push(["normal",new d.n(e.attributeData.normal,n,3)])}(t,i,b),function(e,t,n,o){const i=e.attributeData.colorFeature;null!=i&&("number"==typeof i?t.push(["colorFeatureAttribute",new d.n([i],o,1,!0)]):t.push(["colorFeatureAttribute",new d.n(i,n,1,!0)]))}(t,i,h.indices,b),function(e,t,n,o){const i=e.attributeData.sizeFeature;null!=i&&("number"==typeof i?t.push(["sizeFeatureAttribute",new d.n([i],o,1,!0)]):t.push(["sizeFeatureAttribute",new d.n(i,n,1,!0)]))}(t,i,h.indices,b),function(e,t){const{attributeData:{position:n,timeStamps:o}}=e;if(!o)return;const i=n.length/3,r=new Array(2*(i-1));let a=0;for(let s=0;s<i-1;s++)r[a++]=s,r[a++]=s+1;t.push(["timeStamps",new d.n(o,r,m,!0)])}(t,i),function(e,t,n,o){const i=e.attributeData.opacityFeature;null!=i&&("number"==typeof i?t.push(["opacityFeatureAttribute",new d.n([i],o,1,!0)]):t.push(["opacityFeatureAttribute",new d.n(i,n,1,!0)]))}(t,i,h.indices,b),function(e,t,n){if(null==e.overlayInfo||1!==e.overlayInfo.renderCoordsHelper.viewingMode||!e.overlayInfo.spatialReference.isGeographic)return;const i=(0,l.jh)(n.length),r=(0,a.tO)(e.overlayInfo.spatialReference);for(let o=0;o<i.length;o+=3)(0,s.RC)(n,o,i,o,r);const u=n.length/3,f=(0,c.oe)(u+1);let p=v,h=g,m=0,x=0;(0,o.hZ)(p,i[x++],i[x++]),x++,f[0]=0;for(let a=1;a<u+1;++a)a===u&&(x=0),(0,o.hZ)(h,i[x++],i[x++]),x++,m+=(0,o.xg)(p,h),f[a]=m,[p,h]=[h,p];t.push(["distanceToStart",new d.n(f,t[0][1].indices,1,!0)])}(t,i,x),new p.V(e,i,u,2,n)}const v=(0,i.vt)(),g=(0,i.vt)(),m=4;function x(e,t,n,o,i){if(null==e||0===e.length)return[];const r=[];return e.forEach((e,a)=>{const s=e.length,c=(0,l.jh)(3*s);e.forEach((e,t)=>{c[3*t]=e[0],c[3*t+1]=e[1],c[3*t+2]=e[2]});const u={attributeData:{position:c,normal:t,colorFeature:null===n||void 0===n?void 0:n[a],opacityFeature:null===o||void 0===o?void 0:o[a],sizeFeature:null===i||void 0===i?void 0:i[a]},removeDuplicateStartEnd:!1};r.push(u)}),r}function w(e,t){const n=(0,u.fY)(e.length*m),o=e[0],i=e[e.length-1];for(let r=0;r<e.length;r++)n[r*m]=e[r],n[r*m+1]=o,n[r*m+2]=i,n[r*m+3]=t+.5;return n}},72017:(e,t,n)=>{n.d(t,{zC:()=>se,C1:()=>O,EE:()=>ee,YG:()=>K,nW:()=>te,td:()=>F,_B:()=>re,Nq:()=>oe,DJ:()=>X,Y6:()=>Z,uX:()=>k,Z8:()=>ie,CM:()=>Q,Gj:()=>J,Ho:()=>Y,Nb:()=>ne,Xl:()=>ce,xh:()=>ae});var o=n(20664),i=n(83755),r=n(9392),a=n(44815),s=n(75002),l=n(38496),c=n(13927),u=n(95925),f=n(70667),d=n(50468);function p(e,t){const n=e[t],o=e[t+1],i=e[t+2];return Math.sqrt(n*n+o*o+i*i)}function h(e,t){const n=e[t],o=e[t+1],i=e[t+2],r=1/Math.sqrt(n*n+o*o+i*i);e[t]*=r,e[t+1]*=r,e[t+2]*=r}function v(e,t,n){e[t]*=n,e[t+1]*=n,e[t+2]*=n}var g=n(17345),m=n(86994),x=n(15796);function w(){return null!==b&&void 0!==b||(b=function(){const e=0,t=255,n=new d.n([e,e,e,t,t,e,t,t],[0,1,2,3],2,!0);return new x.F([["uv0",n]])}()),b}let b=null;const A=[[-.5,-.5,.5],[.5,-.5,.5],[.5,.5,.5],[-.5,.5,.5],[-.5,-.5,-.5],[.5,-.5,-.5],[.5,.5,-.5],[-.5,.5,-.5]],y=[0,0,1,-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1],C=[0,0,1,0,1,1,0,1],P=[0,1,2,2,3,0,4,0,3,3,7,4,1,5,6,6,2,1,1,0,4,4,5,1,3,2,6,6,7,3,5,4,7,7,6,5],S=new Array(36);for(let de=0;de<6;de++)for(let e=0;e<6;e++)S[6*de+e]=de;const z=new Array(36);for(let de=0;de<6;de++)z[6*de]=0,z[6*de+1]=1,z[6*de+2]=2,z[6*de+3]=2,z[6*de+4]=3,z[6*de+5]=0;function O(e,t){Array.isArray(t)||(t=[t,t,t]);const n=new Array(24);for(let o=0;o<8;o++)n[3*o]=A[o][0]*t[0],n[3*o+1]=A[o][1]*t[1],n[3*o+2]=A[o][2]*t[2];return new g.V(e,[["position",new d.n(n,P,3,!0)],["normal",new d.n(y,S,3)],["uv0",new d.n(C,z,2)]])}const M=[[-.5,0,-.5],[.5,0,-.5],[.5,0,.5],[-.5,0,.5],[0,-.5,0],[0,.5,0]],D=[0,1,-1,1,1,0,0,1,1,-1,1,0,0,-1,-1,1,-1,0,0,-1,1,-1,-1,0],V=[5,1,0,5,2,1,5,3,2,5,0,3,4,0,1,4,1,2,4,2,3,4,3,0],H=[0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7];function F(e,t){Array.isArray(t)||(t=[t,t,t]);const n=new Array(18);for(let o=0;o<6;o++)n[3*o]=M[o][0]*t[0],n[3*o+1]=M[o][1]*t[1],n[3*o+2]=M[o][2]*t[2];return new g.V(e,[["position",new d.n(n,V,3,!0)],["normal",new d.n(D,H,3)]])}const T=(0,i.fA)(-.5,0,-.5),j=(0,i.fA)(.5,0,-.5),R=(0,i.fA)(0,0,.5),_=(0,i.fA)(0,.5,0),E=(0,i.vt)(),I=(0,i.vt)(),U=(0,i.vt)(),B=(0,i.vt)(),W=(0,i.vt)();(0,o.e)(E,T,_),(0,o.e)(I,T,j),(0,o.i)(U,E,I),(0,o.n)(U,U),(0,o.e)(E,j,_),(0,o.e)(I,j,R),(0,o.i)(B,E,I),(0,o.n)(B,B),(0,o.e)(E,R,_),(0,o.e)(I,R,T),(0,o.i)(W,E,I),(0,o.n)(W,W);const G=[T,j,R,_],N=[0,-1,0,U[0],U[1],U[2],B[0],B[1],B[2],W[0],W[1],W[2]],q=[0,1,2,3,1,0,3,2,1,3,0,2],L=[0,0,0,1,1,1,2,2,2,3,3,3];function Y(e,t){Array.isArray(t)||(t=[t,t,t]);const n=new Array(12);for(let o=0;o<4;o++)n[3*o]=G[o][0]*t[0],n[3*o+1]=G[o][1]*t[1],n[3*o+2]=G[o][2]*t[2];return new g.V(e,[["position",new d.n(n,q,3,!0)],["normal",new d.n(N,L,3)]])}function Q(e,t,n,o){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{uv:!0};const r=-Math.PI,a=2*Math.PI,c=-Math.PI/2,u=Math.PI,f=Math.max(3,Math.floor(n)),p=Math.max(2,Math.floor(o)),h=(f+1)*(p+1),v=(0,s.oe)(3*h),m=(0,s.oe)(3*h),x=(0,s.oe)(2*h),w=[];let b=0;for(let s=0;s<=p;s++){const e=[],n=s/p,o=c+n*u,i=Math.cos(o);for(let s=0;s<=f;s++){const l=s/f,c=r+l*a,u=Math.cos(c)*i,d=Math.sin(o),p=-Math.sin(c)*i;v[3*b]=u*t,v[3*b+1]=d*t,v[3*b+2]=p*t,m[3*b]=u,m[3*b+1]=d,m[3*b+2]=p,x[2*b]=l,x[2*b+1]=n,e.push(b),++b}w.push(e)}const A=new Array;for(let s=0;s<p;s++)for(let e=0;e<f;e++){const t=w[s][e],n=w[s][e+1],o=w[s+1][e+1],i=w[s+1][e];0===s?(A.push(t),A.push(o),A.push(i)):s===p-1?(A.push(t),A.push(n),A.push(o)):(A.push(t),A.push(n),A.push(o),A.push(o),A.push(i),A.push(t))}const y=[["position",new d.n(v,A,3,!0)],["normal",new d.n(m,A,3,!0)]];return i.uv&&y.push(["uv0",new d.n(x,A,2,!0)]),i.offset&&(y[0][0]="offset",y.push(["position",new d.n(Float64Array.from(i.offset),(0,l.EH)(A.length),3,!0)])),new g.V(e,y)}function k(e,t,n,o){const i=Z(t,n,o);return new g.V(e,i)}function Z(e,t,n){const o=e;let i,r;if(n)i=[0,-1,0,1,0,0,0,0,1,-1,0,0,0,0,-1,0,1,0],r=[0,1,2,0,2,3,0,3,4,0,4,1,1,5,2,2,5,3,3,5,4,4,5,1];else{const e=o*(1+Math.sqrt(5))/2;i=[-o,e,0,o,e,0,-o,-e,0,o,-e,0,0,-o,e,0,o,e,0,-o,-e,0,o,-e,e,0,-o,e,0,o,-e,0,-o,-e,0,o],r=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1]}for(let s=0;s<i.length;s+=3)v(i,s,e/p(i,s));let a={};function l(t,n){t>n&&([t,n]=[n,t]);const o=t.toString()+"."+n.toString();if(a[o])return a[o];let r=i.length;return i.length+=3,function(e,t,n,o,i){let r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:t;(i=i||e)[r]=e[t]+n[o],i[r+1]=e[t+1]+n[o+1],i[r+2]=e[t+2]+n[o+2]}(i,3*t,i,3*n,i,r),v(i,r,e/p(i,r)),r/=3,a[o]=r,r}for(let s=0;s<t;s++){const e=r.length,t=new Array(4*e);for(let n=0;n<e;n+=3){const e=r[n],o=r[n+1],i=r[n+2],a=l(e,o),s=l(o,i),c=l(i,e),u=4*n;t[u]=e,t[u+1]=a,t[u+2]=c,t[u+3]=o,t[u+4]=s,t[u+5]=a,t[u+6]=i,t[u+7]=c,t[u+8]=s,t[u+9]=a,t[u+10]=s,t[u+11]=c}r=t,a={}}const c=(0,s.Wz)(i);for(let s=0;s<c.length;s+=3)h(c,s);return[["position",new d.n((0,s.Wz)(i),r,3,!0)],["normal",new d.n(c,r,3,!0)]]}function X(e){let{normal:t,position:n,color:o,rotation:i,size:a,centerOffsetAndDistance:s,uvi:c,featureAttribute:u,olidColor:f=null}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const p=n?(0,r.o8)(n):(0,r.vt)(),h=t?(0,r.o8)(t):(0,r.fA)(0,0,1),v=o?[o[0],o[1],o[2],o.length>3?o[3]:255]:[255,255,255,255],m=null!=a&&2===a.length?a:[1,1],x=null!=i?[i]:[0],b=(0,l.EH)(1),A=[["position",new d.n(p,b,3,!0)],["normal",new d.n(h,b,3,!0)],["color",new d.n(v,b,4,!0)],["size",new d.n(m,b,2)],["rotation",new d.n(x,b,1,!0)]];if(c&&A.push(["uvi",new d.n(c,b,c.length)]),null!=s){const e=[s[0],s[1],s[2],s[3]];A.push(["centerOffsetAndDistance",new d.n(e,b,4)])}if(u){const e=[u[0],u[1],u[2],u[3]];A.push(["featureAttribute",new d.n(e,b,4)])}return new g.V(e,A,null,1,f,void 0,w())}const $=[[-1,-1,0],[1,-1,0],[1,1,0],[-1,1,0]];function J(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:$;const n=new Array(12);for(let a=0;a<4;a++)for(let e=0;e<3;e++)n[3*a+e]=t[a][e];const o=[0,1,2,2,3,0],i=[0,0,0,0,0,0],r=[["position",new d.n(n,o,3,!0)],["normal",new d.n([0,0,1],i,3,!0)],["uv0",new d.n([0,0,1,0,1,1,0,1],o,2,!0)],["color",new d.n([255,255,255,255],i,4,!0)]];return new g.V(e,r)}function K(e,t,n,o){let r=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],a=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],l=0;const c=t,u=e;let f=(0,i.fA)(0,l,0),p=(0,i.fA)(0,l+u,0),h=(0,i.fA)(0,-1,0),v=(0,i.fA)(0,1,0);o&&(l=u,p=(0,i.fA)(0,0,0),f=(0,i.fA)(0,l,0),h=(0,i.fA)(0,1,0),v=(0,i.fA)(0,-1,0));const g=[p,f],m=[h,v],x=n+2,w=Math.sqrt(u*u+c*c);if(o)for(let s=n-1;s>=0;s--){const e=s*(2*Math.PI/n),t=(0,i.fA)(Math.cos(e)*c,l,Math.sin(e)*c);g.push(t);const o=(0,i.fA)(u*Math.cos(e)/w,-c/w,u*Math.sin(e)/w);m.push(o)}else for(let s=0;s<n;s++){const e=s*(2*Math.PI/n),t=(0,i.fA)(Math.cos(e)*c,l,Math.sin(e)*c);g.push(t);const o=(0,i.fA)(u*Math.cos(e)/w,c/w,u*Math.sin(e)/w);m.push(o)}const b=new Array,A=new Array;if(r){for(let e=3;e<g.length;e++)b.push(1),b.push(e-1),b.push(e),A.push(0),A.push(0),A.push(0);b.push(g.length-1),b.push(2),b.push(1),A.push(0),A.push(0),A.push(0)}if(a){for(let e=3;e<g.length;e++)b.push(e),b.push(e-1),b.push(0),A.push(e),A.push(e-1),A.push(1);b.push(0),b.push(2),b.push(g.length-1),A.push(1),A.push(2),A.push(m.length-1)}const y=(0,s.oe)(3*x);for(let i=0;i<x;i++)y[3*i]=g[i][0],y[3*i+1]=g[i][1],y[3*i+2]=g[i][2];const C=(0,s.oe)(3*x);for(let i=0;i<x;i++)C[3*i]=m[i][0],C[3*i+1]=m[i][1],C[3*i+2]=m[i][2];return[["position",new d.n(y,b,3,!0)],["normal",new d.n(C,A,3,!0)]]}function ee(e,t,n,o,i){let r=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],a=!(arguments.length>6&&void 0!==arguments[6])||arguments[6];return new g.V(e,K(t,n,o,i,r,a))}function te(e,t,n,r,a,l,c){const u=a?(0,i.o8)(a):(0,i.fA)(1,0,0),f=l?(0,i.o8)(l):(0,i.fA)(0,0,0);null!==c&&void 0!==c||(c=!0);const p=(0,i.vt)();(0,o.n)(p,u);const h=(0,i.vt)();(0,o.h)(h,p,Math.abs(t));const v=(0,i.vt)();(0,o.h)(v,h,-.5),(0,o.g)(v,v,f);const m=(0,i.fA)(0,1,0);Math.abs(1-(0,o.f)(p,m))<.2&&(0,o.j)(m,0,0,1);const x=(0,i.vt)();(0,o.i)(x,p,m),(0,o.n)(x,x),(0,o.i)(m,x,p);const w=2*r+(c?2:0),b=r+(c?2:0),A=(0,s.oe)(3*w),y=(0,s.oe)(3*b),C=(0,s.oe)(2*w),P=new Array(3*r*(c?4:2)),S=new Array(3*r*(c?4:2));c&&(A[3*(w-2)]=v[0],A[3*(w-2)+1]=v[1],A[3*(w-2)+2]=v[2],C[2*(w-2)]=0,C[2*(w-2)+1]=0,A[3*(w-1)]=A[3*(w-2)]+h[0],A[3*(w-1)+1]=A[3*(w-2)+1]+h[1],A[3*(w-1)+2]=A[3*(w-2)+2]+h[2],C[2*(w-1)]=1,C[2*(w-1)+1]=1,y[3*(b-2)]=-p[0],y[3*(b-2)+1]=-p[1],y[3*(b-2)+2]=-p[2],y[3*(b-1)]=p[0],y[3*(b-1)+1]=p[1],y[3*(b-1)+2]=p[2]);const z=(e,t,n)=>{P[e]=t,S[e]=n};let O=0;const M=(0,i.vt)(),D=(0,i.vt)();for(let i=0;i<r;i++){const e=i*(2*Math.PI/r);(0,o.h)(M,m,Math.sin(e)),(0,o.h)(D,x,Math.cos(e)),(0,o.g)(M,M,D),y[3*i]=M[0],y[3*i+1]=M[1],y[3*i+2]=M[2],(0,o.h)(M,M,n),(0,o.g)(M,M,v),A[3*i]=M[0],A[3*i+1]=M[1],A[3*i+2]=M[2],C[2*i]=i/r,C[2*i+1]=0,A[3*(i+r)]=A[3*i]+h[0],A[3*(i+r)+1]=A[3*i+1]+h[1],A[3*(i+r)+2]=A[3*i+2]+h[2],C[2*(i+r)]=i/r,C[2*i+1]=1;const t=(i+1)%r;z(O++,i,i),z(O++,i+r,i),z(O++,t,t),z(O++,t,t),z(O++,i+r,i),z(O++,t+r,t)}if(c){for(let e=0;e<r;e++){const t=(e+1)%r;z(O++,w-2,b-2),z(O++,e,b-2),z(O++,t,b-2)}for(let e=0;e<r;e++){const t=(e+1)%r;z(O++,e+r,b-1),z(O++,w-1,b-1),z(O++,t+r,b-1)}}const V=[["position",new d.n(A,P,3,!0)],["normal",new d.n(y,S,3,!0)],["uv0",new d.n(C,P,2,!0)]];return new g.V(e,V)}function ne(e,t,n,o,i,r){o=o||10,i=null==i||i,(0,m.vA)(t.length>1);const a=[],s=[];for(let l=0;l<o;l++){a.push([0,-l-1,-(l+1)%o-1]);const e=l/o*2*Math.PI;s.push([Math.cos(e)*n,Math.sin(e)*n])}return oe(e,s,t,[[0,0,0]],a,i,r)}function oe(e,t,n,a,l,f){let p=arguments.length>6&&void 0!==arguments[6]?arguments[6]:(0,i.fA)(0,0,0);const h=t.length,v=(0,s.oe)(n.length*h*3+(6*a.length||0)),m=(0,s.oe)(n.length*h*3+(a?6:0)),x=new Array,w=new Array;let b=0,A=0;const y=(0,r.vt)(),C=(0,r.vt)(),P=(0,r.vt)(),S=(0,r.vt)(),z=(0,r.vt)(),O=(0,r.vt)(),M=(0,r.vt)(),D=(0,r.vt)(),V=(0,r.vt)(),H=(0,r.vt)(),F=(0,r.vt)(),T=(0,r.vt)(),j=(0,r.vt)(),R=(0,c.vt)();(0,o.j)(V,0,1,0),(0,o.e)(C,n[1],n[0]),(0,o.n)(C,C),f?((0,o.g)(D,n[0],p),(0,o.n)(P,D)):(0,o.j)(P,0,0,1),ce(C,P,V,V,z,P,ue),(0,o.d)(S,P),(0,o.d)(T,z);for(let i=0;i<a.length;i++)(0,o.h)(O,z,a[i][0]),(0,o.h)(D,P,a[i][2]),(0,o.g)(O,O,D),(0,o.g)(O,O,n[0]),v[b++]=O[0],v[b++]=O[1],v[b++]=O[2];m[A++]=-C[0],m[A++]=-C[1],m[A++]=-C[2];for(let o=0;o<l.length;o++)x.push(l[o][0]>0?l[o][0]:-l[o][0]-1+a.length),x.push(l[o][1]>0?l[o][1]:-l[o][1]-1+a.length),x.push(l[o][2]>0?l[o][2]:-l[o][2]-1+a.length),w.push(0),w.push(0),w.push(0);let _=a.length;const E=a.length-1;for(let i=0;i<n.length;i++){let e=!1;i>0&&((0,o.d)(y,C),i<n.length-1?((0,o.e)(C,n[i+1],n[i]),(0,o.n)(C,C)):e=!0,(0,o.g)(H,y,C),(0,o.n)(H,H),(0,o.g)(F,n[i-1],S),(0,c.O_)(n[i],H,R),(0,c.Ui)(R,(0,u.LV)(F,y),D)?((0,o.e)(D,D,n[i]),(0,o.n)(P,D),(0,o.i)(z,H,P),(0,o.n)(z,z)):ce(H,S,T,V,z,P,ue),(0,o.d)(S,P),(0,o.d)(T,z)),f&&((0,o.g)(D,n[i],p),(0,o.n)(j,D));for(let r=0;r<h;r++)if((0,o.h)(O,z,t[r][0]),(0,o.h)(D,P,t[r][1]),(0,o.g)(O,O,D),(0,o.n)(M,O),m[A++]=M[0],m[A++]=M[1],m[A++]=M[2],(0,o.g)(O,O,n[i]),v[b++]=O[0],v[b++]=O[1],v[b++]=O[2],!e){const e=(r+1)%h;x.push(_+r),x.push(_+h+r),x.push(_+e),x.push(_+e),x.push(_+h+r),x.push(_+h+e);for(let t=0;t<6;t++){const e=x.length-6;w.push(x[e+t]-E)}}_+=h}const I=n[n.length-1];for(let i=0;i<a.length;i++)(0,o.h)(O,z,a[i][0]),(0,o.h)(D,P,a[i][1]),(0,o.g)(O,O,D),(0,o.g)(O,O,I),v[b++]=O[0],v[b++]=O[1],v[b++]=O[2];const U=A/3;m[A++]=C[0],m[A++]=C[1],m[A++]=C[2];const B=_-h;for(let o=0;o<l.length;o++)x.push(l[o][0]>=0?_+l[o][0]:-l[o][0]-1+B),x.push(l[o][2]>=0?_+l[o][2]:-l[o][2]-1+B),x.push(l[o][1]>=0?_+l[o][1]:-l[o][1]-1+B),w.push(U),w.push(U),w.push(U);const W=[["position",new d.n(v,x,3,!0)],["normal",new d.n(m,w,3,!0)]];return new g.V(e,W)}function ie(e,t,n,o,i){const r=(0,a.jh)(3*t.length),c=new Array(2*(t.length-1));let u=0,p=0;for(let a=0;a<t.length;a++){for(let e=0;e<3;e++)r[u++]=t[a][e];a>0&&(c[p++]=a-1,c[p++]=a)}const h=[["position",new d.n(r,c,3,!0)]];if(n&&n.length===t.length&&3===n[0].length){const e=(0,s.oe)(3*n.length);let o=0;for(let i=0;i<t.length;i++)for(let t=0;t<3;t++)e[o++]=n[i][t];h.push(["normal",new d.n(e,c,3,!0)])}if(o&&h.push(["color",new d.n(o,(0,l.tM)(o.length/4),4)]),i&&i.length===t.length){const e=(0,f.xJ)(i,1);h.push(["timeStamps",new d.n(e,c,f.Uf,!0)])}return new g.V(e,h,null,2)}function re(e,t,n,o,i){let r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const a=new Array(18),s=[[-n,r,i/2],[o,r,i/2],[0,t+r,i/2],[-n,r,-i/2],[o,r,-i/2],[0,t+r,-i/2]];for(let l=0;l<6;l++)a[3*l]=s[l][0],a[3*l+1]=s[l][1],a[3*l+2]=s[l][2];return new g.V(e,[["position",new d.n(a,[0,1,2,3,0,2,2,5,3,1,4,5,5,2,1,1,0,3,3,4,1,4,3,5],3,!0)]])}function ae(e,t){const n=e.getMutableAttribute("position").data;for(let i=0;i<n.length;i+=3){const e=n[i],r=n[i+1],a=n[i+2];(0,o.j)(fe,e,r,a),(0,o.t)(fe,fe,t),n[i]=fe[0],n[i+1]=fe[1],n[i+2]=fe[2]}}function se(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e;const n=e.attributes,o=n.get("position").data,i=n.get("normal").data;if(i){const e=t.getMutableAttribute("normal").data;for(let t=0;t<i.length;t+=3){const n=i[t+1];e[t+1]=-i[t+2],e[t+2]=n}}if(o){const e=t.getMutableAttribute("position").data;for(let t=0;t<o.length;t+=3){const n=o[t+1];e[t+1]=-o[t+2],e[t+2]=n}}}function le(e,t,n,i,r){return!(Math.abs((0,o.f)(t,e))>r)&&((0,o.i)(n,e,t),(0,o.n)(n,n),(0,o.i)(i,n,e),(0,o.n)(i,i),!0)}function ce(e,t,n,o,i,r,a){return le(e,t,i,r,a)||le(e,n,i,r,a)||le(e,o,i,r,a)}const ue=.99619469809,fe=(0,r.vt)()},72900:(e,t,n)=>{n.d(t,{CN:()=>s,I9:()=>f,PY:()=>l,Q_:()=>a,ny:()=>c,sZ:()=>u});n(81806);var o=n(55855),i=n(76632),r=n(93345);const a=128,s=.5,l=(0,o.CN)(s/2,s/2,1-s/2,1-s/2);function c(e){return"cross"===e||"x"===e}function u(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:a,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t*s,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const{data:r,parameters:l}=f(e,t,n,o);return new i.g(r,l)}function f(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:a;return{data:d(e,t,arguments.length>2&&void 0!==arguments[2]?arguments[2]:t*s,arguments.length>3&&void 0!==arguments[3]?arguments[3]:0),parameters:{mipmap:!1,wrap:{s:33071,t:33071},width:t,height:t,noUnpackFlip:!0,dataType:r.ld.FLOAT,pixelFormat:6403,internalFormat:r.H0.R16F,reloadable:!0}}}function d(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:a,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t*s,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;switch(e){case"circle":default:return function(e,t){const n=e/2-.5;return m(e,v(n,n,t/2))}(t,n);case"square":return function(e,t){return p(e,t,!1)}(t,n);case"cross":return function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return h(e,t,!1,n)}(t,n,o);case"x":return function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return h(e,t,!0,n)}(t,n,o);case"kite":return function(e,t){return p(e,t,!0)}(t,n);case"triangle":return function(e,t){return m(e,g(e/2,t,t/2))}(t,n);case"arrow":return function(e,t){const n=t,o=t/2,i=e/2,r=.8*n,a=v(i,(e-t)/2-r,Math.sqrt(r*r+o*o)),s=g(i,n,o);return m(e,(e,t)=>Math.max(s(e,t),-a(e,t)))}(t,n)}}function p(e,t,n){return n&&(t/=Math.SQRT2),m(e,(o,i)=>{let r=o-.5*e+.25,a=.5*e-i-.75;if(n){const e=(r+a)/Math.SQRT2;a=(a-r)/Math.SQRT2,r=e}return Math.max(Math.abs(r),Math.abs(a))-.5*t})}function h(e,t,n){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;t-=o,n&&(t*=Math.SQRT2);const i=.5*t;return m(e,(t,r)=>{let a,s=t-.5*e,l=.5*e-r-1;if(n){const e=(s+l)/Math.SQRT2;l=(l-s)/Math.SQRT2,s=e}return s=Math.abs(s),l=Math.abs(l),a=s>l?s>i?Math.sqrt((s-i)*(s-i)+l*l):l:l>i?Math.sqrt(s*s+(l-i)*(l-i)):s,a-=o/2,a})}function v(e,t,n){return(o,i)=>{const r=o-e,a=i-t;return Math.sqrt(r*r+a*a)-n}}function g(e,t,n){const o=Math.sqrt(t*t+n*n);return(i,r)=>{const a=Math.abs(i-e)-n,s=r-e+t/2+.75,l=(t*a+n*s)/o,c=-s;return Math.max(l,c)}}function m(e,t){const n=new Float32Array(e*e);for(let o=0;o<e;o++)for(let i=0;i<e;i++)n[i+e*o]=t(i,o)/e;return n}},81284:(e,t,n)=>{function o(e){return"point"===e.type}n.d(t,{v:()=>o})},83755:(e,t,n)=>{function o(){return new Float32Array(3)}function i(e){const t=new Float32Array(3);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t}function r(e,t,n){const o=new Float32Array(3);return o[0]=e,o[1]=t,o[2]=n,o}function a(){return o()}function s(){return r(1,1,1)}function l(){return r(1,0,0)}function c(){return r(0,1,0)}function u(){return r(0,0,1)}n.d(t,{fA:()=>r,o8:()=>i,vt:()=>o});const f=a(),d=s(),p=l(),h=c(),v=u();Object.freeze(Object.defineProperty({__proto__:null,ONES:d,UNIT_X:p,UNIT_Y:h,UNIT_Z:v,ZEROS:f,clone:i,create:o,fromValues:r,ones:s,unitX:l,unitY:c,unitZ:u,zeros:a},Symbol.toStringTag,{value:"Module"}))},84248:(e,t,n)=>{n.d(t,{R:()=>k});var o=n(89379),i=n(15941),r=n(86300),a=n(44680),s=n(34761),l=n(13191),c=n(19555),u=n(72745),f=n(20664),d=n(9392),p=n(55855);function h(e){return function(e){return e instanceof Float32Array&&e.length>=16}(e)||function(e){return Array.isArray(e)&&e.length>=16}(e)}var v=n(2413),g=n(88105),m=n(63048),x=n(22955),w=n(34981),b=n(40318),A=n(75803),y=n(45463),C=n(12028),P=n(86994),S=n(52757),z=n(99362),O=n(19061),M=n(57481),D=n(48549),V=n(16506),H=n(59246),F=n(61785),T=n(60322),j=n(93345),R=n(57162),_=n(75757);class E extends H.w{constructor(e,t){super(e,t,new V.$(O.H,()=>n.e(271).then(n.bind(n,60271))),(0,_._u)([U,G()].map(M.U))),this.primitiveType=t.occlusionPass?j.WR.POINTS:j.WR.TRIANGLE_STRIP}initializePipeline(e){const{oitPass:t,hasPolygonOffset:n,draped:o,output:i,depthTestEnabled:r,occlusionPass:a}=e,s=r&&!o&&!(1===t)&&!a&&!(9===i);return(0,R.Ey)({blending:(0,w.RN)(i)?(0,T.Yf)(t,!0):null,depthTest:r&&!o?{func:515}:null,depthWrite:s?R.Uy:null,drawBuffers:(0,T.m6)(t,i),colorWrite:R.kn,polygonOffset:n?I:null})}}const I={factor:0,units:-4},U=(0,D.BP)().vec2u8("uv0",{glNormalized:!0}),B=(0,D.BP)().vec3f("position").vec3f("normal").vec4i16("uvi").vec4u8("color").vec2f("size").f32("rotation").vec4f("centerOffsetAndDistance").vec4f("featureAttribute"),W=B.clone().vec4u8("olidColor");function G(){return(0,F.E)()?W:B}var N=n(6326),q=n(6485),L=n(92656);class Y extends L.E{constructor(e){super(),this.spherical=e,this.screenCenterOffsetUnitsEnabled=!1,this.occlusionTestEnabled=!0,this.signedDistanceFieldEnabled=!1,this.sampleSignedDistanceFieldTexelCenter=!1,this.hasVVSize=!1,this.hasVVColor=!1,this.hasVerticalOffset=!1,this.hasScreenSizePerspective=!1,this.hasRotation=!1,this.debugDrawLabelBorder=!1,this.hasPolygonOffset=!1,this.depthTestEnabled=!0,this.pixelSnappingEnabled=!0,this.draped=!1,this.terrainDepthTest=!1,this.cullAboveTerrain=!1,this.occlusionPass=!1,this.occludedFragmentFade=!1,this.horizonCullingEnabled=!0,this.isFocused=!0,this.olidColorInstanced=!1,this.textureCoordinateType=0,this.emissionSource=0,this.discardInvisibleFragments=!0,this.hasVVInstancing=!1,this.snowCover=!1}}(0,N.Cg)([(0,q.W)()],Y.prototype,"screenCenterOffsetUnitsEnabled",void 0),(0,N.Cg)([(0,q.W)()],Y.prototype,"occlusionTestEnabled",void 0),(0,N.Cg)([(0,q.W)()],Y.prototype,"signedDistanceFieldEnabled",void 0),(0,N.Cg)([(0,q.W)()],Y.prototype,"sampleSignedDistanceFieldTexelCenter",void 0),(0,N.Cg)([(0,q.W)()],Y.prototype,"hasVVSize",void 0),(0,N.Cg)([(0,q.W)()],Y.prototype,"hasVVColor",void 0),(0,N.Cg)([(0,q.W)()],Y.prototype,"hasVerticalOffset",void 0),(0,N.Cg)([(0,q.W)()],Y.prototype,"hasScreenSizePerspective",void 0),(0,N.Cg)([(0,q.W)()],Y.prototype,"hasRotation",void 0),(0,N.Cg)([(0,q.W)()],Y.prototype,"debugDrawLabelBorder",void 0),(0,N.Cg)([(0,q.W)()],Y.prototype,"hasPolygonOffset",void 0),(0,N.Cg)([(0,q.W)()],Y.prototype,"depthTestEnabled",void 0),(0,N.Cg)([(0,q.W)()],Y.prototype,"pixelSnappingEnabled",void 0),(0,N.Cg)([(0,q.W)()],Y.prototype,"draped",void 0),(0,N.Cg)([(0,q.W)()],Y.prototype,"terrainDepthTest",void 0),(0,N.Cg)([(0,q.W)()],Y.prototype,"cullAboveTerrain",void 0),(0,N.Cg)([(0,q.W)()],Y.prototype,"occlusionPass",void 0),(0,N.Cg)([(0,q.W)()],Y.prototype,"occludedFragmentFade",void 0),(0,N.Cg)([(0,q.W)()],Y.prototype,"horizonCullingEnabled",void 0),(0,N.Cg)([(0,q.W)()],Y.prototype,"isFocused",void 0);var Q=n(75569);class k extends y.i{constructor(e,t){super(e,xe),this.produces=new Map([[13,e=>(0,w.Mb)(e)&&!this.parameters.drawAsLabel],[14,e=>(0,w.Mb)(e)&&this.parameters.drawAsLabel],[12,()=>this.parameters.occlusionTest],[18,e=>this.parameters.draped&&(0,w.Mb)(e)]]),this._visible=!0,this._configuration=new Y(t)}getConfiguration(e,t){const n=this.parameters.draped;return super.getConfiguration(e,t,this._configuration),this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.hasVerticalOffset=!!this.parameters.verticalOffset,this._configuration.hasScreenSizePerspective=!!this.parameters.screenSizePerspective,this._configuration.screenCenterOffsetUnitsEnabled="screen"===this.parameters.centerOffsetUnits,this._configuration.hasPolygonOffset=this.parameters.polygonOffset,this._configuration.draped=n,this._configuration.occlusionTestEnabled=this.parameters.occlusionTest,this._configuration.pixelSnappingEnabled=this.parameters.pixelSnappingEnabled,this._configuration.signedDistanceFieldEnabled=this.parameters.textureIsSignedDistanceField,this._configuration.sampleSignedDistanceFieldTexelCenter=this.parameters.sampleSignedDistanceFieldTexelCenter,this._configuration.hasRotation=this.parameters.hasRotation,this._configuration.hasVVSize=!!this.parameters.vvSize,this._configuration.hasVVColor=!!this.parameters.vvColor,this._configuration.occlusionPass=12===t.slot,this._configuration.occludedFragmentFade=!n&&this.parameters.occludedFragmentFade,this._configuration.horizonCullingEnabled=this.parameters.horizonCullingEnabled,this._configuration.isFocused=this.parameters.isFocused,this._configuration.depthTestEnabled=this.parameters.depthEnabled||12===t.slot,(0,w.RN)(e)&&(this._configuration.debugDrawLabelBorder=!!x.b.LABELS_SHOW_BORDER),this._configuration.oitPass=t.oitPass,this._configuration.terrainDepthTest=t.terrainDepthTest,this._configuration.cullAboveTerrain=t.cullAboveTerrain,this._configuration}intersect(e,t,n,o,i,a){const{options:{selectionMode:l,hud:c,excludeLabels:u},point:h,camera:v}=n,{parameters:g}=this;if(!l||!c||u&&g.isLabel||!e.visible||!h||!v)return;const m=e.attributes.get("featureAttribute"),x=null==m?null:(0,p.ci)(m.data,de),{scaleX:w,scaleY:b}=be(x,g,v.pixelRatio);(0,r.z0)(ae,t),e.attributes.has("featureAttribute")&&function(e){const t=e[0],n=e[1],o=e[2],i=e[3],r=e[4],a=e[5],s=e[6],l=e[7],c=e[8],u=1/Math.sqrt(t*t+n*n+o*o),f=1/Math.sqrt(i*i+r*r+a*a),d=1/Math.sqrt(s*s+l*l+c*c);e[0]=t*u,e[1]=n*u,e[2]=o*u,e[3]=i*f,e[4]=r*f,e[5]=a*f,e[6]=s*d,e[7]=l*d,e[8]=c*d}(ae);const A=e.attributes.get("position"),y=e.attributes.get("size"),C=e.attributes.get("normal"),S=e.attributes.get("rotation"),z=e.attributes.get("centerOffsetAndDistance");(0,P.vA)(A.size>=3);const M=(0,O.c)(g),D="screen"===this.parameters.centerOffsetUnits;for(let r=0;r<A.data.length/A.size;r++){const e=r*A.size;(0,f.j)(K,A.data[e],A.data[e+1],A.data[e+2]),(0,f.t)(K,K,t),(0,f.t)(K,K,v.viewMatrix);const o=r*z.size;if((0,f.j)(ue,z.data[o],z.data[o+1],z.data[o+2]),!D&&(K[0]+=ue[0],K[1]+=ue[1],0!==ue[2])){const e=ue[2];(0,f.n)(ue,K),(0,f.e)(K,K,(0,f.h)(ue,ue,e))}const i=r*C.size;if((0,f.j)(ee,C.data[i],C.data[i+1],C.data[i+2]),X(ee,ae,v,pe),Ae(this.parameters,K,pe,v,J),v.applyProjection(K,te),te[0]>-1){D&&(ue[0]||ue[1])&&(te[0]+=ue[0]*v.pixelRatio,0!==ue[1]&&(te[1]+=J.alignmentEvaluator.apply(ue[1])*v.pixelRatio),v.unapplyProjection(te,K)),te[0]+=this.parameters.screenOffset[0]*v.pixelRatio,te[1]+=this.parameters.screenOffset[1]*v.pixelRatio,te[0]=Math.floor(te[0]),te[1]=Math.floor(te[1]);const e=r*y.size;ge[0]=y.data[e],ge[1]=y.data[e+1],J.evaluator.applyVec2(ge,ge);const t=he*v.pixelRatio;let o=0;g.textureIsSignedDistanceField&&(o=Math.min(g.outlineSize,.5*ge[0])*v.pixelRatio/2),ge[0]*=w,ge[1]*=b;const i=r*S.size,l=g.rotation+S.data[i];if($(h,te[0],te[1],ge,t,o,l,g,M)){const e=n.ray;if((0,f.t)(oe,K,(0,s.B8)(le,v.viewMatrix)),te[0]=h[0],te[1]=h[1],v.unprojectFromRenderScreen(te,K)){const t=(0,d.vt)();(0,f.d)(t,e.direction);const n=1/(0,f.b)(t);(0,f.h)(t,t,n),a((0,f.k)(e.origin,K)*n,t,-1,oe)}}}}}intersectDraped(e,t,n,o,i){const r=e.attributes.get("position"),a=e.attributes.get("size"),s=e.attributes.get("rotation"),l=this.parameters,c=(0,O.c)(l),u=e.attributes.get("featureAttribute"),f=null==u?null:(0,p.ci)(u.data,de),{scaleX:d,scaleY:h}=be(f,l,e.screenToWorldRatio),v=ve*e.screenToWorldRatio;for(let p=0;p<r.data.length/r.size;p++){const t=p*r.size,u=r.data[t],f=r.data[t+1],g=p*a.size;ge[0]=a.data[g],ge[1]=a.data[g+1];let m=0;l.textureIsSignedDistanceField&&(m=Math.min(l.outlineSize,.5*ge[0])*e.screenToWorldRatio/2),ge[0]*=d,ge[1]*=h;const x=p*s.size,w=l.rotation+s.data[x];$(n,u,f,ge,v,m,w,l,c)&&o(i.distance,i.normal,-1)}}createBufferWriter(){return new we}applyShaderOffsetsView(e,t,n,o,i,r,a){const s=X(t,n,i,pe);return this._applyVerticalGroundOffsetView(e,s,i,a),Ae(this.parameters,a,s,i,r),this._applyPolygonOffsetView(a,s,o[3],i,a),this._applyCenterOffsetView(a,o,a),a}applyShaderOffsetsNDC(e,t,n,o,i){return this._applyCenterOffsetNDC(e,t,n,o),null!=i&&(0,f.d)(i,o),this._applyPolygonOffsetNDC(o,t,n,o),o}_applyPolygonOffsetView(e,t,n,o,r){const a=o.aboveGround?1:-1;let s=Math.sign(n);0===s&&(s=a);const l=a*s;if(this.parameters.shaderPolygonOffset<=0)return(0,f.d)(r,e);const c=(0,i.qE)(Math.abs(t.cosAngle),.01,1),u=1-Math.sqrt(1-c*c)/c/o.viewport[2];return(0,f.h)(r,e,l>0?u:1/u),r}_applyVerticalGroundOffsetView(e,t,n,o){const i=(0,f.b)(e),r=n.aboveGround?1:-1,a=n.computeRenderPixelSizeAtDist(i)*b.R,s=(0,f.h)(K,t.normal,r*a);return(0,f.g)(o,e,s),o}_applyCenterOffsetView(e,t,n){const o="screen"!==this.parameters.centerOffsetUnits;return n!==e&&(0,f.d)(n,e),o&&(n[0]+=t[0],n[1]+=t[1],t[2]&&((0,f.n)(ee,n),(0,f.a)(n,n,(0,f.h)(ee,ee,t[2])))),n}_applyCenterOffsetNDC(e,t,n,o){const i="screen"!==this.parameters.centerOffsetUnits;return o!==e&&(0,f.d)(o,e),i||(o[0]+=t[0]/n.fullWidth*2,o[1]+=t[1]/n.fullHeight*2),o}_applyPolygonOffsetNDC(e,t,n,o){const i=this.parameters.shaderPolygonOffset;if(e!==o&&(0,f.d)(o,e),i){const e=n.aboveGround?1:-1,r=e*Math.sign(t[3]);o[2]-=(r||e)*i}return o}set visible(e){this._visible=e}get visible(){const{color:e,outlineSize:t,outlineColor:n}=this.parameters,o=e[3]>=Q.Q||t>=Q.Q&&n[3]>=Q.Q;return this._visible&&o}createGLMaterial(e){return new Z(e)}calculateRelativeScreenBounds(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:(0,v.vt)();return function(e,t,n,o){o[0]=e.anchorPosition[0]*-t[0]+e.screenOffset[0]*n,o[1]=e.anchorPosition[1]*-t[1]+e.screenOffset[1]*n}(this.parameters,e,t,n),n[2]=n[0]+e[0],n[3]=n[1]+e[1],n}}class Z extends A.m8{constructor(e){super((0,o.A)((0,o.A)({},e),e.material.parameters))}beginSlot(e){return this.updateTexture(this._material.parameters.textureId),this._material.setParameters(this.textureBindParameters),this.getTechnique(E,e)}}function X(e,t,n,o){return h(t)&&(t=(0,r.z0)(se,t)),(0,f.o)(o.normal,e,t),(0,f.t)(o.normal,o.normal,n.viewInverseTransposeMatrix),o.cosAngle=(0,f.f)(ne,me),o}function $(e,t,n,o,r,a,s,l,u){let f=t-r-o[0]*u[0],d=f+o[0]+2*r,p=n-r-o[1]*u[1],h=p+o[1]+2*r;const v=l.distanceFieldBoundingBox;return l.textureIsSignedDistanceField&&null!=v&&(f+=o[0]*v[0],p+=o[1]*v[1],d-=o[0]*(1-v[2]),h-=o[1]*(1-v[3]),f-=a,d+=a,p-=a,h+=a),(0,c.hZ)(re,t,n),(0,c.e$)(ie,e,re,(0,i.kU)(s)),ie[0]>f&&ie[0]<d&&ie[1]>p&&ie[1]<h}const J=new C.fc,K=(0,d.vt)(),ee=(0,d.vt)(),te=(0,p.vt)(),ne=(0,d.vt)(),oe=(0,d.vt)(),ie=(0,u.vt)(),re=(0,u.vt)(),ae=(0,a.vt)(),se=(0,a.vt)(),le=(0,l.vt)(),ce=(0,p.vt)(),ue=(0,d.vt)(),fe=(0,d.vt)(),de=(0,p.vt)(),pe={normal:ne,cosAngle:0},he=1,ve=2,ge=(0,u.fA)(0,0),me=(0,d.fA)(0,0,1);class xe extends A.NV{constructor(){super(...arguments),this.renderOccluded=1,this.isDecoration=!1,this.color=(0,p.CN)(1,1,1,1),this.polygonOffset=!1,this.anchorPosition=(0,u.fA)(.5,.5),this.screenOffset=[0,0],this.shaderPolygonOffset=1e-5,this.textureIsSignedDistanceField=!1,this.sampleSignedDistanceFieldTexelCenter=!1,this.outlineColor=(0,p.CN)(1,1,1,1),this.outlineSize=0,this.distanceFieldBoundingBox=(0,p.vt)(),this.rotation=0,this.hasRotation=!1,this.vvSizeEnabled=!1,this.vvSize=null,this.vvColor=null,this.vvOpacity=null,this.vvSymbolAnchor=null,this.vvSymbolRotationMatrix=null,this.hasSlicePlane=!1,this.pixelSnappingEnabled=!0,this.occlusionTest=!0,this.occludedFragmentFade=!1,this.horizonCullingEnabled=!1,this.centerOffsetUnits="world",this.drawAsLabel=!1,this.depthEnabled=!0,this.isFocused=!0,this.focusStyle="bright",this.draped=!1,this.isLabel=!1}get hasVVSize(){return!!this.vvSize}get hasVVColor(){return!!this.vvColor}get hasVVOpacity(){return!!this.vvOpacity}}class we{constructor(){this.layout=U,this.instanceLayout=G()}elementCount(e){return e.get("position").indices.length}elementCountBaseInstance(e){return e.get("uv0").indices.length}write(e,t,n,o,i,r){var a;const{position:s,normal:l,color:c,size:u,rotation:f,centerOffsetAndDistance:d,featureAttribute:p,uvi:h}=i;(0,S.Hk)(n.get("position"),e,s,r),(0,S.p1)(n.get("normal"),t,l,r);const v=n.get("position").indices.length;let m=0,x=0,w=O.f,b=O.f;const A=null===(a=n.get("uvi"))||void 0===a?void 0:a.data;A&&A.length>=4&&(m=A[0],x=A[1],w=A[2],b=A[3]);for(let g=0;g<v;++g){const e=r+g;h.setValues(e,m,x,w,b)}if((0,S.tb)(n.get("color"),4,c,r),(0,S.Ue)(n.get("size"),u,r),(0,S.uO)(n.get("rotation"),f,r),n.get("centerOffsetAndDistance")?(0,S.Ut)(n.get("centerOffsetAndDistance"),d,r):(0,S.Pq)(d,r,v),n.get("featureAttribute")?(0,S.Ut)(n.get("featureAttribute"),p,r):(0,S.Pq)(p,r,v),null!=o){var y;const e=null===(y=n.get("position"))||void 0===y?void 0:y.indices;if(e){const t=e.length,n=i.getField("olidColor",g.XP);(0,S.vx)(o,n,t,r)}}return{numVerticesPerItem:1,numItems:v}}writeBaseInstance(e,t){const{uv0:n}=t;(0,S.Ue)(e.get("uv0"),n,0)}intersect(e,t,n,o,i,r,a){const{options:{selectionMode:l,hud:c,excludeLabels:u},point:p,camera:h}=o;if(!l||!c||u&&t.isLabel||!p)return;const v=this.instanceLayout.createView(e),{position:g,normal:m,rotation:x,size:w,featureAttribute:b,centerOffsetAndDistance:A}=v,y="screen"===t.centerOffsetUnits,C=(0,O.c)(t);if(null==g||null==m||null==x||null==w||null==A||null==h)return;const P=null==b?null:b.getVec(0,de),{scaleX:S,scaleY:z}=be(P,t,h.pixelRatio),M=g.count;for(let O=0;O<M;O++){if(g.getVec(O,K),null!=n&&(0,f.g)(K,K,n),(0,f.t)(K,K,h.viewMatrix),A.getVec(O,ce),(0,f.j)(ue,ce[0],ce[1],ce[2]),!y&&(K[0]+=ue[0],K[1]+=ue[1],0!==ue[2])){const e=ue[2];(0,f.n)(ue,K),(0,f.e)(K,K,(0,f.h)(ue,ue,e))}if(m.getVec(O,ee),X(ee,ae,h,pe),Ae(t,K,pe,h,J),h.applyProjection(K,te),te[0]>-1){y&&(ue[0]||ue[1])&&(te[0]+=ue[0]*h.pixelRatio,0!==ue[1]&&(te[1]+=J.alignmentEvaluator.apply(ue[1])*h.pixelRatio),h.unapplyProjection(te,K)),te[0]+=t.screenOffset[0]*h.pixelRatio,te[1]+=t.screenOffset[1]*h.pixelRatio,te[0]=Math.floor(te[0]),te[1]=Math.floor(te[1]),w.getVec(O,ge),J.evaluator.applyVec2(ge,ge);const e=he*h.pixelRatio;let n=0;t.textureIsSignedDistanceField&&(n=Math.min(t.outlineSize,.5*ge[0])*h.pixelRatio/2),ge[0]*=S,ge[1]*=z;const i=x.get(O),r=t.rotation+i;if($(p,te[0],te[1],ge,e,n,r,t,C)){const e=o.ray;if((0,f.t)(oe,K,(0,s.B8)(le,h.viewMatrix)),te[0]=p[0],te[1]=p[1],h.unprojectFromRenderScreen(te,K)){const t=(0,d.vt)();(0,f.d)(t,e.direction);const n=1/(0,f.b)(t);(0,f.h)(t,t,n),a((0,f.k)(e.origin,K)*n,t,O,oe)}}}}}}function be(e,t,n){return null==e||null==t.vvSize?{scaleX:n,scaleY:n}:((0,m.VC)(fe,t,e),{scaleX:fe[0]*n,scaleY:fe[1]*n})}function Ae(e,t,n,o,i){var r,a;if(null===(r=e.verticalOffset)||void 0===r||!r.screenLength){const o=(0,f.b)(t);return i.update(n.cosAngle,o,e.screenSizePerspective,e.screenSizePerspectiveMinPixelReferenceSize,e.screenSizePerspectiveAlignment,null),t}const s=(0,f.b)(t),l=null!==(a=e.screenSizePerspectiveAlignment)&&void 0!==a?a:e.screenSizePerspective,c=(0,z.kE)(o,s,e.verticalOffset,n.cosAngle,l,e.screenSizePerspectiveMinPixelReferenceSize);return i.update(n.cosAngle,s,e.screenSizePerspective,e.screenSizePerspectiveMinPixelReferenceSize,e.screenSizePerspectiveAlignment,null),(0,f.h)(n.normal,n.normal,c),(0,f.g)(t,t,n.normal)}},94587:(e,t,n)=>{n.d(t,{fY:()=>r});var o=n(78393),i=n(62984);function r(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return e<=o.y9?t?new Array(e).fill(0):new Array(e):(0,i.Bg)(e)}},98720:(e,t,n)=>{n.d(t,{K:()=>l});var o,i,r=n(57528),a=n(67582),s=n(86955);function l(e){e.uniforms.add(new a.o("alignPixelEnabled",e=>e.alignPixelEnabled)),e.code.add((0,s.H)(o||(o=(0,r.A)(["vec4 alignToPixelCenter(vec4 clipCoord, vec2 widthHeight) {\nif (!alignPixelEnabled)\nreturn clipCoord;\nvec2 xy = vec2(0.500123) + 0.5 * clipCoord.xy / clipCoord.w;\nvec2 pixelSz = vec2(1.0) / widthHeight;\nvec2 ij = (floor(xy * widthHeight) + vec2(0.5)) * pixelSz;\nvec2 result = (ij * 2.0 - vec2(1.0)) * clipCoord.w;\nreturn vec4(result, clipCoord.zw);\n}"])))),e.code.add((0,s.H)(i||(i=(0,r.A)(["vec4 alignToPixelOrigin(vec4 clipCoord, vec2 widthHeight) {\nif (!alignPixelEnabled)\nreturn clipCoord;\nvec2 xy = vec2(0.5) + 0.5 * clipCoord.xy / clipCoord.w;\nvec2 pixelSz = vec2(1.0) / widthHeight;\nvec2 ij = floor((xy + 0.5 * pixelSz) * widthHeight) * pixelSz;\nvec2 result = (ij * 2.0 - vec2(1.0)) * clipCoord.w;\nreturn vec4(result, clipCoord.zw);\n}"]))))}}}]);
//# sourceMappingURL=3804.929b3414.chunk.js.map