"use strict";(self.webpackChunkmmsp_land_hl=self.webpackChunkmmsp_land_hl||[]).push([[9478],{32411:(t,e,n)=>{n.d(e,{T5:()=>c,uu:()=>a});var r=n(2413),o=n(46533);n(34111);var i=n(73582);n(80963);function l(t,e,n){const{extent:r,valid:o}=t,[i,l,s,a]=r;return!(n<l||n>a)&&(null!=o&&i>s?e>=s||e<=i:e>=i&&e<=s)}function s(t,e,n,o){const{extent:l,modelSize:s,valid:a}=t,[c,u,f]=l,h=function(t,e,n){if(null!=n&&t>e){const[r,o]=n;return o-t+(e-r)}return e-t}(c,f,a);let d=e/s[0]*h+c;return null!=a&&o&&(d=new i.hr(a[0],a[1]).normalize(d)),[d,(s[1]-n)/s[1]*(0,r.uJ)(l)+u]}function a(t){return t?4:3}function c(t,e,n){const[i,a]=n.modelSize;let c=null;const u=new Map;e.forEach(e=>{u.set(e.lij,(0,o.DE)(t,e))});const f=(t,e,n)=>(0,r.Rj)(t.extent,e,n);return(o,h)=>{var d;const w=Math.round(o),m=Math.round(h);if(!t.wrapAround&&(w<0||w>=i||m<0||m>=a))return[0,0];const[g,p]=s(n,o,h,!0);if(!l(n,g,p))return[0,0];if(null==c||!f(c,g,p)){c=null;for(const[t,n]of e)if(f(n,g,p)){c=n;break}}if(null==(null===(d=c)||void 0===d?void 0:d.data))return[0,0];const y=u.get(c.lij);if(null==y)return[0,0];const{width:v,height:x,extent:M}=c;return y((g-M[0])/(0,r.VL)(M)*v,x-(p-M[1])/(0,r.uJ)(M)*x)}}},46533:(t,e,n)=>{n.d(e,{CW:()=>d,DE:()=>w,S1:()=>p,pH:()=>v});var r=n(89379),o=n(81806),i=n(76460),l=n(15941),s=n(50346),a=n(47249),c=n(76797),u=n(80963);const f=()=>i.A.getLogger("esri.views.2d.engine.flow.dataUtils"),h=10;async function d(t,e,n,r){const i=performance.now(),l=w(e,n),c=performance.now(),u=p(e,l,n.width,n.height),d=performance.now(),m=function(t,e){const n=new a.A,r=t.reduce((t,e)=>t+e.vertices.length,0),o=new Float32Array(4*r),i=new Array(t.length);let l=0,s=0;for(const{vertices:a}of t){const t=l;for(const e of a)o[4*l]=e.x,o[4*l+1]=e.y,o[4*l+2]=e.t,o[4*l+3]=e.speed,l++;i[s++]={startVertex:t,numberOfVertices:a.length,totalTime:a[a.length-1].t,timeSeed:e?n.getFloat():0}}return{lineVertices:o,lineDescriptors:i}}(u,!0),g=performance.now(),y="Streamlines"===t?function(t,e){const n=9,{lineVertices:r,lineDescriptors:o}=t;let i=0,l=0;for(const d of o)i+=2*d.numberOfVertices,l+=6*(d.numberOfVertices-1);const s=new Float32Array(i*n),a=new Uint32Array(l);let c=0,u=0;function f(){a[u++]=c-2,a[u++]=c,a[u++]=c-1,a[u++]=c,a[u++]=c+1,a[u++]=c-1}function h(t,e,r,o,i,l,a,u){const f=c*n;let h=0;s[f+h++]=t,s[f+h++]=e,s[f+h++]=1,s[f+h++]=r,s[f+h++]=l,s[f+h++]=a,s[f+h++]=o/2,s[f+h++]=i/2,s[f+h++]=u,c++,s[f+h++]=t,s[f+h++]=e,s[f+h++]=-1,s[f+h++]=r,s[f+h++]=l,s[f+h++]=a,s[f+h++]=-o/2,s[f+h++]=-i/2,s[f+h++]=u,c++}for(const d of o){const{totalTime:t,timeSeed:n}=d;let o=null,i=null,l=null,s=null,a=null,c=null;for(let u=0;u<d.numberOfVertices;u++){const w=r[4*(d.startVertex+u)],m=r[4*(d.startVertex+u)+1],g=r[4*(d.startVertex+u)+2],p=r[4*(d.startVertex+u)+3];let y=null,v=null,x=null,M=null;if(u>0){y=w-o,v=m-i;const r=Math.sqrt(y*y+v*v);if(y/=r,v/=r,u>1){let t=y+a,n=v+c;const r=Math.sqrt(t*t+n*n);t/=r,n/=r;const o=Math.min(1/(t*y+n*v),e);t*=o,n*=o,x=-n,M=t}else x=-v,M=y;null!==x&&null!==M&&(h(o,i,l,x,M,t,n,p),f())}o=w,i=m,l=g,a=y,c=v,s=p}h(o,i,l,-c,a,t,n,s)}return{vertexData:s,indexData:a}}(m,h):function(t){const e=16,n=1,r=2,{lineVertices:o,lineDescriptors:i}=t;let l=0,s=0;for(const P of i){const t=P.numberOfVertices-1;l+=4*t*2,s+=6*t*2}const a=new Float32Array(l*e),c=new Uint32Array(s);let u,f,h,d,w,m,g,p,y,v,x,M,A,D,F=0,S=0;function I(){c[S++]=F-8,c[S++]=F-7,c[S++]=F-6,c[S++]=F-7,c[S++]=F-5,c[S++]=F-6,c[S++]=F-4,c[S++]=F-3,c[S++]=F-2,c[S++]=F-3,c[S++]=F-1,c[S++]=F-2}function k(t,o,i,l,s,c,u,f,h,d,w,m,g,p){const y=F*e;let v=0;for(const e of[n,r])for(const n of[1,2,3,4])a[y+v++]=t,a[y+v++]=o,a[y+v++]=i,a[y+v++]=l,a[y+v++]=u,a[y+v++]=f,a[y+v++]=h,a[y+v++]=d,a[y+v++]=e,a[y+v++]=n,a[y+v++]=g,a[y+v++]=p,a[y+v++]=s/2,a[y+v++]=c/2,a[y+v++]=w/2,a[y+v++]=m/2,F++}function V(t,e){let n=y+x,r=v+M;const o=Math.sqrt(n*n+r*r);n/=o,r/=o;const i=y*n+v*r;n/=i,r/=i;let l=x+A,s=M+D;const a=Math.sqrt(l*l+s*s);l/=a,s/=a;const c=x*l+M*s;l/=c,s/=c,k(u,f,h,d,-r,n,w,m,g,p,-s,l,t,e),I()}function b(t,e,n,r,o,i){if(y=x,v=M,x=A,M=D,null==y&&null==v&&(y=x,v=M),null!=w&&null!=m){A=t-w,D=e-m;const n=Math.sqrt(A*A+D*D);A/=n,D/=n}null!=y&&null!=v&&V(o,i),u=w,f=m,h=g,d=p,w=t,m=e,g=n,p=r}function L(t,e){y=x,v=M,x=A,M=D,null==y&&null==v&&(y=x,v=M),null!=y&&null!=v&&V(t,e)}for(const P of i){u=null,f=null,h=null,d=null,w=null,m=null,g=null,p=null,y=null,v=null,x=null,M=null,A=null,D=null;const{totalTime:t,timeSeed:e}=P;for(let n=0;n<P.numberOfVertices;n++)b(o[4*(P.startVertex+n)],o[4*(P.startVertex+n)+1],o[4*(P.startVertex+n)+2],o[4*(P.startVertex+n)+3],t,e);L(t,e)}return{vertexData:a,indexData:c}}(m),v=performance.now();return(0,o.A)("esri-2d-profiler")&&(f().info("I.1","_createFlowFieldFromData (ms)",Math.round(c-i)),f().info("I.2","_getStreamlines (ms)",Math.round(d-c)),f().info("I.3","createAnimatedLinesData (ms)",Math.round(g-d)),f().info("I.4","create{Streamlines|Particles}Mesh (ms)",Math.round(v-g)),f().info("I.5","createFlowMesh (ms)",Math.round(v-i)),f().info("I.6","Mesh size (bytes)",y.vertexData.buffer.byteLength+y.indexData.buffer.byteLength)),await Promise.resolve(),(0,s.Te)(r),y}function w(t,e){const n=function(t,e,n,r){if(0===r)return t;const o=Math.round(3*r),i=new Array(2*o+1);let l=0;for(let c=-o;c<=o;c++){const t=Math.exp(-c*c/(r*r));i[c+o]=t,l+=t}for(let c=-o;c<=o;c++)i[c+o]/=l;const s=new Float32Array(t.length);for(let c=0;c<n;c++)for(let n=0;n<e;n++){let r=0,l=0;for(let s=-o;s<=o;s++){if(n+s<0||n+s>=e)continue;const a=i[s+o];r+=a*t[2*(c*e+(n+s))],l+=a*t[2*(c*e+(n+s))+1]}s[2*(c*e+n)]=r,s[2*(c*e+n)+1]=l}const a=new Float32Array(t.length);for(let c=0;c<e;c++)for(let t=0;t<n;t++){let r=0,l=0;for(let a=-o;a<=o;a++){if(t+a<0||t+a>=n)continue;const u=i[a+o];r+=u*s[2*((t+a)*e+c)],l+=u*s[2*((t+a)*e+c)+1]}a[2*(t*e+c)]=r,a[2*(t*e+c)+1]=l}return a}(e.data,e.width,e.height,t.smoothing);return t.interpolate?(t,r)=>{const o=Math.floor(t),i=Math.floor(r);if(o<0||o>=e.width)return[0,0];if(i<0||i>=e.height)return[0,0];const l=t-o,s=r-i,a=o,c=i,u=o<e.width-1?o+1:o,f=i<e.height-1?i+1:i,h=n[2*(c*e.width+a)],d=n[2*(c*e.width+u)],w=n[2*(f*e.width+a)],m=n[2*(f*e.width+u)],g=n[2*(c*e.width+a)+1],p=n[2*(c*e.width+u)+1];return[(h*(1-s)+w*s)*(1-l)+(d*(1-s)+m*s)*l,(g*(1-s)+n[2*(f*e.width+a)+1]*s)*(1-l)+(p*(1-s)+n[2*(f*e.width+u)+1]*s)*l]}:(t,r)=>{const o=Math.round(t),i=Math.round(r);return o<0||o>=e.width||i<0||i>=e.height?[0,0]:[n[2*(i*e.width+o)],n[2*(i*e.width+o)+1]]}}function m(t,e,n,r,o,i,s,a){const c=[],{raster:u,width:f,height:h,resolutionFactor:d}=a;let w=r,m=o,g=0,[p,y]=n(w,m);p*=e.velocityScale,y*=e.velocityScale;const v=Math.sqrt(p*p+y*y);let x,M;c.push({x:w,y:m,t:g,speed:v});for(let A=0;A<e.verticesPerLine;A++){let[r,o]=n(w,m);r*=e.velocityScale,o*=e.velocityScale;const a=Math.sqrt(r*r+o*o);if(a<e.minSpeedThreshold)return c;const p=t*r/a,y=t*o/a;if(w+=p*e.segmentLength,m+=y*e.segmentLength,e.wrapAround&&(w=(0,l.OS)(w,i[0])),g+=t*e.segmentLength/a,Math.acos(p*x+y*M)>e.maxTurnAngle)return c;if(e.collisions){let t=Math.round(w*d);const n=Math.round(m*d);if(e.wrapAround&&(t=(0,l.OS)(t,f)),t<0||t>f-1||n<0||n>h-1)return c;const r=u[n*f+t];if(-1!==r&&r!==s)return c;u[n*f+t]=s}c.push({x:w,y:m,t:g,speed:a}),x=p,M=y}return c}function g(t,e,n,o,i,l,s,a){const c=Math.round((.2+.6*s.getFloat())*t.verticesPerLine),u=t.verticesPerLine-c,f=m(-1,(0,r.A)((0,r.A)({},t),{},{verticesPerLine:u}),e,n,o,i,l,a),h=m(1,(0,r.A)((0,r.A)({},t),{},{verticesPerLine:c}),e,n,o,i,l,a),d=f.reverse();return d.splice(-1,1),d.concat(h)}function p(t,e,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{positions:[]};if(t.density<=0)return[];const{positions:i}=o,l=[],s=new a.A,c=1/Math.max(t.lineCollisionWidth,1),u=Math.round(n*c),f=Math.round(r*c),h=new Int32Array(u*f);for(let a=0;a<h.length;a++)h[a]=-1;const d={raster:h,width:u,height:f,resolutionFactor:c},w={},p=t.lineSpacing/Math.sqrt(t.density),y=Math.floor(r/p),v=Math.floor(n/p);for(let a=0;a<y;a++){const t=a*p;for(let e=0;e<v;e++){const n=e*p;w["".concat(e,"-").concat(a)]={x:n,y:t,positions:[]}}}for(const{x:a,y:m}of i){const t=w["".concat(Math.floor(a/p),"-").concat(Math.floor(m/p))];t&&t.positions.push([a,m])}const x=[];for(const a in w){const t=w[a];if(0===t.positions.length)x.push({x:t.x+p/2,y:t.y+p/2,sort:.66+.33*s.getFloat(),stage:0});else{const[e]=t.positions.splice(0,1);x.push({x:e[0],y:e[1],sort:.33*s.getFloat(),stage:1});for(const[n,r]of t.positions)x.push({x:n,y:r,sort:.33+.33*s.getFloat(),stage:2})}}x.sort((t,e)=>t.sort-e.sort);for(const{x:a,y:M,stage:A}of x){const o=t.onlyForwardTracing?m(1,t,e,a,M,[n,r],l.length,d):g(t,e,a,M,[n,r],l.length,s,d);o.length<2||l.push({stage:A,vertices:o})}return l}function y(t,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:e.width,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:e.height,o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const s=e.pixels,a=n*r,c=new Float32Array(2*a),u=e.width,f=(t,e)=>t+o+(e+i)*u,h=(t,e)=>t+e*n;let d;if(null!=e.mask)if(n!==e.width||r!==e.height||0!==o||0!==i){d=new Uint8Array(2*a);const t=e.mask;for(let e=0;e<r;++e)for(let r=0;r<n;++r){const n=f(r,e),o=h(r,e);d[2*o]=t[2*n],d[2*o+1]=t[2*n+1]}}else d=e.mask;else d=new Uint8Array(2*a),d.fill(255);if("vector-uv"===t)for(let l=0;l<r;++l)for(let t=0;t<n;++t){const e=f(t,l),n=h(t,l);c[2*n]=s[0][e],c[2*n+1]=-s[1][e]}else if("vector-magdir"===t){const{cos:t,sin:e}=Math;for(let o=0;o<r;++o)for(let r=0;r<n;++r){const n=f(r,o),i=h(r,o),a=s[0][n],u=(0,l.kU)(s[1][n]),d=t(u-Math.PI/2),w=e(u-Math.PI/2);c[2*i]=d*a,c[2*i+1]=w*a}}return{data:c,mask:d,width:n,height:r}}async function v(t,e,n,r,i,l){const s=performance.now(),a=(0,u.Vp)(e.spatialReference);if(!a){const a=await x(t,e,n,r,i,l);return(0,o.A)("esri-2d-profiler")&&f().info("I.7","loadImagery, early exit (ms)",Math.round(performance.now()-s)),(0,o.A)("esri-2d-profiler")&&f().info("I.9","Number of parts",1),a}const[h,d]=a.valid,w=d-h,m=Math.ceil(e.width/w),g=e.width/m,p=Math.round(n/m);let y=e.xmin;const v=[],M=performance.now();for(let o=0;o<m;o++){const n=new c.A({xmin:y,xmax:y+g,ymin:e.ymin,ymax:e.ymax,spatialReference:e.spatialReference});v.push(x(t,n,p,r,i,l)),y+=g}const A=await Promise.all(v);if((0,o.A)("esri-2d-profiler")&&f().info("I.8","All calls to _fetchPart (ms)",Math.round(performance.now()-M)),(0,o.A)("esri-2d-profiler")&&f().info("I.9","Number of parts",A.length),1===A.length)return(0,o.A)("esri-2d-profiler")&&f().info("I.10","loadImagery, general exit without stitching back (ms)",Math.round(performance.now()-s)),A[0];const D={data:new Float32Array(n*r*2),mask:new Uint8Array(n*r),width:n,height:r};let F=0;for(const o of A){for(let t=0;t<o.height;t++)for(let e=0;e<o.width;e++)F+e>=n||(D.data[2*(t*n+F+e)]=o.data[2*(t*o.width+e)],D.data[2*(t*n+F+e)+1]=o.data[2*(t*o.width+e)+1],D.mask[t*n+F+e]=o.mask[t*o.width+e]);F+=o.width}return(0,o.A)("esri-2d-profiler")&&f().info("I.10","loadImagery, general exit (ms)",Math.round(performance.now()-s)),D}async function x(t,e,n,r,o,i){const l={requestProjectedLocalDirections:!0,signal:i};if(null!=o&&(l.timeExtent=o),"imagery"===t.type){var s;await t.load({signal:i});const o=await t.internalFetchImage(e,n,r,l);return null==(null===o||void 0===o||null===(s=o.pixelData)||void 0===s?void 0:s.pixelBlock)?{data:new Float32Array(n*r*2),mask:new Uint8Array(n*r),width:n,height:r}:y(t.rasterInfo.dataType,o.pixelData.pixelBlock)}await t.load({signal:i});const a=await t.fetchPixels(e,n,r,l);return null==(null===a||void 0===a?void 0:a.pixelBlock)?{data:new Float32Array(n*r*2),mask:new Uint8Array(n*r),width:n,height:r}:y(t.serviceRasterInfo.dataType,a.pixelBlock)}},59478:(t,e,n)=>{n.r(e),n.d(e,{default:()=>a});var r=n(6326),o=(n(76460),n(81806),n(47249),n(50076),n(87990)),i=n(46533),l=n(32411);let s=class{constructor(){this._tileData=new Map}async generateStreamlines(t){const{flowData:e,flowExtentInfo:n,needsMagnitude:r,simulationSettings:o,startPositions:l}=t,s=c((0,i.DE)(o,e),o,n.modelSize,r,l);return{result:{streamlines:s},transferList:null===s||void 0===s?void 0:s.map(t=>t.vertices.buffer)}}async generateTiledStreamlines(t){var e;const{flowDataTiles:n,flowExtentInfo:r,needsMagnitude:o,reset:i,simulationSettings:s,startPositions:a}=t;this._updateTileData(n,i);const u=c((0,l.T5)(s,this._tileData,r),s,r.modelSize,o,a);return{result:{streamlines:u},transferList:null!==(e=null===u||void 0===u?void 0:u.map(t=>t.vertices.buffer))&&void 0!==e?e:[]}}_updateTileData(t,e){e&&this._tileData.forEach((e,n)=>{null==t.get(n)&&this._tileData.delete(n)}),t.forEach((t,e)=>{"delete"===t.type?this._tileData.delete(e):"on-worker"!==t.type&&"waiting"!==t.type&&this._tileData.set(e,t.data)})}};s=(0,r.Cg)([(0,o.$)("esri.views.3d.support.flow.FlowWorker")],s);const a=s;function c(t,e,n,r,o){if(null==t)return;const s=(0,i.S1)(e,t,n[0],n[1],{positions:o}),a=[],c=(0,l.uu)(r);for(const{vertices:i,stage:l}of s){const t=new Float32Array(i.length*c);for(let e=0;e<i.length;e++)t[e*c]=i[e].x,t[e*c+1]=i[e].y,t[e*c+2]=i[e].t,r&&(t[e*c+3]=i[e].speed);a.push({vertices:t,stage:l,hasMagnitude:r})}return a}}}]);
//# sourceMappingURL=9478.a19d7bd7.chunk.js.map